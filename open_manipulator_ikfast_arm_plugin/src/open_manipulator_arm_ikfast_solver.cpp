/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-01-25 01:09:10.700305
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17;
x0=IKcos(j[0]);
x1=IKcos(j[2]);
x2=IKcos(j[1]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKsin(j[0]);
x7=IKcos(j[3]);
x8=((0.126)*x4);
x9=((0.124)*x1);
x10=((0.128)*x3);
x11=((0.124)*x4);
x12=((0.126)*x1);
x13=(x2*x6);
x14=(x0*x2);
x15=(x0*x3);
x16=(x3*x6);
x17=(x12*x2);
IkReal x18=((1.0)*x8);
IkReal x19=((1.0)*x15);
eetrans[0]=((0.012)+((x0*x10))+((x14*x9))+((x5*(((((-1.0)*x14*x18))+(((-1.0)*x12*x19))))))+((x7*((((x12*x14))+(((-1.0)*x15*x18))))))+(((-1.0)*x11*x19))+(((0.024)*x14)));
IkReal x20=((1.0)*x8);
IkReal x21=((1.0)*x16);
eetrans[1]=(((x10*x6))+(((-1.0)*x11*x21))+((x5*(((((-1.0)*x13*x20))+(((-1.0)*x12*x21))))))+(((0.024)*x13))+((x13*x9))+((x7*(((((-1.0)*x16*x20))+((x12*x13)))))));
IkReal x22=((1.0)*x3);
IkReal x23=((1.0)*x2);
eetrans[2]=((0.0765)+(((-1.0)*x22*x9))+(((0.128)*x2))+((x7*(((((-1.0)*x23*x8))+(((-1.0)*x12*x22))))))+((x5*(((((-1.0)*x17))+((x3*x8))))))+(((-1.0)*x11*x23))+(((-0.024)*x3)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 4; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=((-0.012)+px);
new_py=py;
new_pz=((-0.0765)+pz);
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
j2eval[0]=((1.0)+(((2.03225806451613)*cj3))+(((1.03251821019771)*(cj3*cj3)))+(((1.03251821019771)*(sj3*sj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=0.304;
j1eval[1]=pz;
if((pz*pz) < -0.00001)
continue;
j1eval[2]=((16.2788205960997)*(IKsqrt(pz*pz)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
px=0;
py=0;
pp=pz*pz;
j2eval[0]=((1.0)+(((2.03225806451613)*cj3))+(((1.03251821019771)*(cj3*cj3)))+(((1.03251821019771)*(sj3*sj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=0;
pz=0;
IkReal x24=cj3*cj3;
j2eval[0]=((1.27746947335607)+(((-1.0)*x24)));
j2eval[1]=((1.0)+(((3.60400006496105)*(sj3*sj3))));
j2eval[2]=IKsign(((77960569.0)+(((-61027344.0)*x24))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
px=0;
py=0;
pp=0;
pz=0;
j2eval[0]=((1.27746947335607)+(((-1.0)*(cj3*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x25=cj3*cj3;
CheckValue<IkReal> x26=IKPowWithIntegerCheck(((188614.27983871)+(((-147646.8)*x25))),-1);
if(!x26.valid){
continue;
}
CheckValue<IkReal> x27=IKPowWithIntegerCheck(((37722.8559677419)+(((-29529.36)*x25))),-1);
if(!x27.valid){
continue;
}
if( IKabs(((x26.value)*(((79008.0)+(((28123.2)*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x27.value)*(((-2962.8)+(((29998.08)*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x26.value)*(((79008.0)+(((28123.2)*sj3))))))+IKsqr(((x27.value)*(((-2962.8)+(((29998.08)*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x26.value)*(((79008.0)+(((28123.2)*sj3))))), ((x27.value)*(((-2962.8)+(((29998.08)*sj3))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x28=IKcos(j2);
IkReal x29=IKsin(j2);
IkReal x30=(sj3*x29);
IkReal x31=(sj3*x28);
evalcond[0]=((-0.128)+(((0.126)*x31))+(((0.0663709677419355)*x29)));
evalcond[1]=((0.024)+(((0.0663709677419355)*x28))+(((-0.126)*x30)));
evalcond[2]=((0.03392)+(((-0.006048)*x30))+(((-0.032256)*x31))+(((0.0031858064516129)*x28))+(((-0.0169909677419355)*x29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x32=((0.126)*sj3);
j1eval[0]=((IKabs(((-0.128)+(((0.0663709677419355)*sj2))+((cj2*x32)))))+(IKabs(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x32))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x33=((0.126)*sj3);
j1eval[0]=((IKabs(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x33)))))+(IKabs(((0.128)+(((-0.0663709677419355)*sj2))+(((-1.0)*cj2*x33))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x34=((0.126)*sj3);
CheckValue<IkReal> x36 = IKatan2WithCheck(IkReal(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x34)))),IkReal(((0.128)+(((-0.0663709677419355)*sj2))+(((-1.0)*cj2*x34)))),IKFAST_ATAN2_MAGTHRESH);
if(!x36.valid){
continue;
}
IkReal x35=x36.value;
j1array[0]=((-1.0)*x35);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x35)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x37=IKcos(j1);
IkReal x38=IKsin(j1);
IkReal x39=((0.126)*sj3);
evalcond[0]=((((0.024)*x38))+(((-1.0)*sj2*x38*x39))+(((0.0663709677419355)*sj2*x37))+((cj2*x37*x39))+(((-0.128)*x37))+(((0.0663709677419355)*cj2*x38)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x40=((0.126)*sj3);
CheckValue<IkReal> x42 = IKatan2WithCheck(IkReal(((-0.128)+(((0.0663709677419355)*sj2))+((cj2*x40)))),IkReal(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x40)))),IKFAST_ATAN2_MAGTHRESH);
if(!x42.valid){
continue;
}
IkReal x41=x42.value;
j1array[0]=((-1.0)*x41);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x41)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x43=IKcos(j1);
IkReal x44=IKsin(j1);
IkReal x45=((0.126)*sj3);
evalcond[0]=((((0.024)*x43))+(((0.128)*x44))+(((-0.0663709677419355)*sj2*x44))+(((-1.0)*cj2*x44*x45))+(((-1.0)*sj2*x43*x45))+(((0.0663709677419355)*cj2*x43)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x46 = IKatan2WithCheck(IkReal(((32656640.0)+(((11624256.0)*sj3)))),IkReal(((-6123120.0)+(((61996032.0)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x46.valid){
continue;
}
CheckValue<IkReal> x47=IKPowWithIntegerCheck(IKsign(((77960569.0)+(((-61027344.0)*(cj3*cj3))))),-1);
if(!x47.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x46.value)+(((1.5707963267949)*(x47.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x48=IKcos(j2);
IkReal x49=IKsin(j2);
IkReal x50=(sj3*x49);
IkReal x51=(sj3*x48);
evalcond[0]=((-0.128)+(((0.0663709677419355)*x49))+(((0.126)*x51)));
evalcond[1]=((0.024)+(((0.0663709677419355)*x48))+(((-0.126)*x50)));
evalcond[2]=((0.03392)+(((-0.032256)*x51))+(((-0.0169909677419355)*x49))+(((0.0031858064516129)*x48))+(((-0.006048)*x50)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x52=((0.126)*sj3);
j1eval[0]=((IKabs(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x52)))))+(IKabs(((-0.128)+((cj2*x52))+(((0.0663709677419355)*sj2))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x53=((0.126)*sj3);
j1eval[0]=((IKabs(((0.128)+(((-0.0663709677419355)*sj2))+(((-1.0)*cj2*x53)))))+(IKabs(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x53))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x54=((0.126)*sj3);
CheckValue<IkReal> x56 = IKatan2WithCheck(IkReal(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x54)))),IkReal(((0.128)+(((-0.0663709677419355)*sj2))+(((-1.0)*cj2*x54)))),IKFAST_ATAN2_MAGTHRESH);
if(!x56.valid){
continue;
}
IkReal x55=x56.value;
j1array[0]=((-1.0)*x55);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x55)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x57=IKcos(j1);
IkReal x58=IKsin(j1);
IkReal x59=((0.126)*sj3);
evalcond[0]=((((0.0663709677419355)*cj2*x58))+((cj2*x57*x59))+(((0.024)*x58))+(((-1.0)*sj2*x58*x59))+(((0.0663709677419355)*sj2*x57))+(((-0.128)*x57)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x60=((0.126)*sj3);
CheckValue<IkReal> x62 = IKatan2WithCheck(IkReal(((-0.128)+(((0.0663709677419355)*sj2))+((cj2*x60)))),IkReal(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x60)))),IKFAST_ATAN2_MAGTHRESH);
if(!x62.valid){
continue;
}
IkReal x61=x62.value;
j1array[0]=((-1.0)*x61);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x61)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x63=IKcos(j1);
IkReal x64=IKsin(j1);
IkReal x65=((0.126)*sj3);
evalcond[0]=((((0.0663709677419355)*cj2*x63))+(((0.024)*x63))+(((-1.0)*sj2*x63*x65))+(((-0.0663709677419355)*sj2*x64))+(((0.128)*x64))+(((-1.0)*cj2*x64*x65)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x66=((0.005952)+(((0.006048)*cj3))+(((-0.032256)*sj3)));
IkReal x67=((-0.031744)+(((-0.032256)*cj3))+(((-0.006048)*sj3)));
CheckValue<IkReal> x70 = IKatan2WithCheck(IkReal(x66),IkReal(x67),IKFAST_ATAN2_MAGTHRESH);
if(!x70.valid){
continue;
}
IkReal x68=((1.0)*(x70.value));
if((((x67*x67)+(x66*x66))) < -0.00001)
continue;
CheckValue<IkReal> x71=IKPowWithIntegerCheck(IKabs(IKsqrt(((x67*x67)+(x66*x66)))),-1);
if(!x71.valid){
continue;
}
if( (((x71.value)*(((0.048212)+(((0.031248)*cj3))+(((-1.0)*(pz*pz))))))) < -1-IKFAST_SINCOS_THRESH || (((x71.value)*(((0.048212)+(((0.031248)*cj3))+(((-1.0)*(pz*pz))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x69=IKasin(((x71.value)*(((0.048212)+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))))));
j2array[0]=((((-1.0)*x68))+(((-1.0)*x69)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+x69+(((-1.0)*x68)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x72=((0.126)*sj2);
IkReal x73=((0.126)*cj2);
j1eval[0]=pz;
j1eval[1]=((IKabs(((0.128)+(((-1.0)*cj3*x72))+(((-0.124)*sj2))+(((-1.0)*sj3*x73)))))+(IKabs(((-0.024)+(((-1.0)*cj3*x73))+((sj3*x72))+(((-0.124)*cj2))))));
j1eval[2]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
px=0;
py=0;
pp=pz*pz;
IkReal x74=((1.01612903225806)*pz);
j1eval[0]=((((-1.0)*cj3*sj2*x74))+(((-1.0)*cj2*sj3*x74))+(((-1.0)*pz*sj2))+(((1.03225806451613)*pz)));
j1eval[1]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x75=((0.126)*sj3);
j1eval[0]=((IKabs(((-0.128)+(((0.0663709677419355)*sj2))+((cj2*x75)))))+(IKabs(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x75))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x76=((0.126)*sj3);
j1eval[0]=((IKabs(((0.128)+(((-0.0663709677419355)*sj2))+(((-1.0)*cj2*x76)))))+(IKabs(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x76))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x77=((0.126)*sj3);
CheckValue<IkReal> x79 = IKatan2WithCheck(IkReal(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x77)))),IkReal(((0.128)+(((-0.0663709677419355)*sj2))+(((-1.0)*cj2*x77)))),IKFAST_ATAN2_MAGTHRESH);
if(!x79.valid){
continue;
}
IkReal x78=x79.value;
j1array[0]=((-1.0)*x78);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x78)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x80=IKcos(j1);
IkReal x81=IKsin(j1);
IkReal x82=((0.126)*sj3);
evalcond[0]=((((-0.128)*x80))+(((-1.0)*sj2*x81*x82))+(((0.024)*x81))+(((0.0663709677419355)*sj2*x80))+((cj2*x80*x82))+(((0.0663709677419355)*cj2*x81)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x83=((0.126)*sj3);
CheckValue<IkReal> x85 = IKatan2WithCheck(IkReal(((-0.128)+(((0.0663709677419355)*sj2))+((cj2*x83)))),IkReal(((0.024)+(((-1.0)*sj2*x83))+(((0.0663709677419355)*cj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x85.valid){
continue;
}
IkReal x84=x85.value;
j1array[0]=((-1.0)*x84);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x84)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x86=IKcos(j1);
IkReal x87=IKsin(j1);
IkReal x88=((0.126)*sj3);
evalcond[0]=((((-0.0663709677419355)*sj2*x87))+(((0.024)*x86))+(((-1.0)*cj2*x87*x88))+(((-1.0)*sj2*x86*x88))+(((0.128)*x87))+(((0.0663709677419355)*cj2*x86)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x89=cj2*cj2;
IkReal x90=(cj3*sj2);
IkReal x91=((0.126)*pz);
IkReal x92=(cj3*sj3);
IkReal x93=((0.124)*sj2);
IkReal x94=(cj2*sj2);
IkReal x95=(cj2*sj3);
CheckValue<IkReal> x96=IKPowWithIntegerCheck(((((-1.0)*pz*x93))+(((-1.0)*x90*x91))+(((-1.0)*x91*x95))+(((0.128)*pz))),-1);
if(!x96.valid){
continue;
}
CheckValue<IkReal> x97=IKPowWithIntegerCheck(pz,-1);
if(!x97.valid){
continue;
}
if( IKabs(((x96.value)*(((-0.003072)+(((0.031752)*x89*x92))+(((-0.015876)*x92))+(((-0.015624)*sj3))+(((0.003024)*x95))+(((0.003024)*x90))+(((-0.015872)*cj2))+(((0.031752)*cj2*cj3*x90))+(((-0.0005)*x94))+(((-0.016128)*cj2*cj3))+(((0.002976)*sj2))+(((0.016128)*sj2*sj3))+(((0.031248)*cj2*x90))+(((0.031248)*sj3*x89)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x97.value)*(((0.128)+(((-1.0)*x93))+(((-0.126)*x95))+(((-0.126)*x90)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x96.value)*(((-0.003072)+(((0.031752)*x89*x92))+(((-0.015876)*x92))+(((-0.015624)*sj3))+(((0.003024)*x95))+(((0.003024)*x90))+(((-0.015872)*cj2))+(((0.031752)*cj2*cj3*x90))+(((-0.0005)*x94))+(((-0.016128)*cj2*cj3))+(((0.002976)*sj2))+(((0.016128)*sj2*sj3))+(((0.031248)*cj2*x90))+(((0.031248)*sj3*x89))))))+IKsqr(((x97.value)*(((0.128)+(((-1.0)*x93))+(((-0.126)*x95))+(((-0.126)*x90))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x96.value)*(((-0.003072)+(((0.031752)*x89*x92))+(((-0.015876)*x92))+(((-0.015624)*sj3))+(((0.003024)*x95))+(((0.003024)*x90))+(((-0.015872)*cj2))+(((0.031752)*cj2*cj3*x90))+(((-0.0005)*x94))+(((-0.016128)*cj2*cj3))+(((0.002976)*sj2))+(((0.016128)*sj2*sj3))+(((0.031248)*cj2*x90))+(((0.031248)*sj3*x89))))), ((x97.value)*(((0.128)+(((-1.0)*x93))+(((-0.126)*x95))+(((-0.126)*x90))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x98=IKcos(j1);
IkReal x99=IKsin(j1);
IkReal x100=((0.126)*cj2);
IkReal x101=((0.124)*cj2);
IkReal x102=((0.124)*sj2);
IkReal x103=((0.126)*sj2);
IkReal x104=(sj3*x103);
IkReal x105=(pz*x99);
IkReal x106=(pz*x98);
IkReal x107=(cj3*x99);
IkReal x108=(cj3*x98);
evalcond[0]=((-0.128)+((cj3*x103))+((sj3*x100))+x106+x102);
evalcond[1]=((0.024)+((cj3*x100))+(((-1.0)*x104))+x105+x101);
evalcond[2]=((0.014292)+(((0.256)*x106))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-0.048)*x105)));
evalcond[3]=((((-1.0)*x102*x99))+(((0.024)*x98))+((x101*x98))+(((0.128)*x99))+(((-1.0)*sj3*x100*x99))+(((-1.0)*x103*x107))+(((-1.0)*x104*x98))+((x100*x108)));
evalcond[4]=((((-0.128)*x98))+((x102*x98))+(((0.024)*x99))+((x101*x99))+((x103*x108))+pz+((sj3*x100*x98))+(((-1.0)*x104*x99))+((x100*x107)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x112=IKPowWithIntegerCheck(pz,-1);
if(!x112.valid){
continue;
}
IkReal x109=x112.value;
IkReal x110=(cj3*sj2);
IkReal x111=(cj2*sj3);
CheckValue<IkReal> x113=IKPowWithIntegerCheck(x109,-2);
if(!x113.valid){
continue;
}
if( IKabs(((0.166666666666667)*x109*(((5.8825)+(((-4.032)*x110))+(((-4.032)*x111))+(((-125.0)*(x113.value)))+(((3.906)*cj3))+(((-3.968)*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x109*(((0.128)+(((-0.126)*x110))+(((-0.126)*x111))+(((-0.124)*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.166666666666667)*x109*(((5.8825)+(((-4.032)*x110))+(((-4.032)*x111))+(((-125.0)*(x113.value)))+(((3.906)*cj3))+(((-3.968)*sj2))))))+IKsqr((x109*(((0.128)+(((-0.126)*x110))+(((-0.126)*x111))+(((-0.124)*sj2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.166666666666667)*x109*(((5.8825)+(((-4.032)*x110))+(((-4.032)*x111))+(((-125.0)*(x113.value)))+(((3.906)*cj3))+(((-3.968)*sj2))))), (x109*(((0.128)+(((-0.126)*x110))+(((-0.126)*x111))+(((-0.124)*sj2))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x114=IKcos(j1);
IkReal x115=IKsin(j1);
IkReal x116=((0.126)*cj2);
IkReal x117=((0.124)*cj2);
IkReal x118=((0.124)*sj2);
IkReal x119=((0.126)*sj2);
IkReal x120=(sj3*x119);
IkReal x121=(pz*x115);
IkReal x122=(pz*x114);
IkReal x123=(cj3*x115);
IkReal x124=(cj3*x114);
evalcond[0]=((-0.128)+((cj3*x119))+((sj3*x116))+x122+x118);
evalcond[1]=((0.024)+((cj3*x116))+(((-1.0)*x120))+x121+x117);
evalcond[2]=((0.014292)+(((0.256)*x122))+(((0.031248)*cj3))+(((-0.048)*x121))+(((-1.0)*(pz*pz))));
evalcond[3]=((((-1.0)*x119*x123))+((x114*x117))+(((0.128)*x115))+(((-1.0)*sj3*x115*x116))+(((-1.0)*x115*x118))+(((0.024)*x114))+((x116*x124))+(((-1.0)*x114*x120)));
evalcond[4]=(((x114*x118))+(((-1.0)*x115*x120))+(((0.024)*x115))+pz+((sj3*x114*x116))+((x116*x123))+((x115*x117))+((x119*x124))+(((-0.128)*x114)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x125=((0.126)*sj2);
IkReal x126=((0.126)*cj2);
CheckValue<IkReal> x127 = IKatan2WithCheck(IkReal(((-0.024)+((sj3*x125))+(((-1.0)*cj3*x126))+(((-0.124)*cj2)))),IkReal(((0.128)+(((-1.0)*sj3*x126))+(((-0.124)*sj2))+(((-1.0)*cj3*x125)))),IKFAST_ATAN2_MAGTHRESH);
if(!x127.valid){
continue;
}
CheckValue<IkReal> x128=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x128.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x127.value)+(((1.5707963267949)*(x128.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x129=IKcos(j1);
IkReal x130=IKsin(j1);
IkReal x131=((0.126)*cj2);
IkReal x132=((0.124)*cj2);
IkReal x133=((0.124)*sj2);
IkReal x134=((0.126)*sj2);
IkReal x135=(sj3*x134);
IkReal x136=(pz*x130);
IkReal x137=(pz*x129);
IkReal x138=(cj3*x130);
IkReal x139=(cj3*x129);
evalcond[0]=((-0.128)+((cj3*x134))+((sj3*x131))+x137+x133);
evalcond[1]=((0.024)+((cj3*x131))+x136+x132+(((-1.0)*x135)));
evalcond[2]=((0.014292)+(((0.256)*x137))+(((0.031248)*cj3))+(((-0.048)*x136))+(((-1.0)*(pz*pz))));
evalcond[3]=(((x129*x132))+(((-1.0)*x134*x138))+(((-1.0)*sj3*x130*x131))+(((0.128)*x130))+((x131*x139))+(((0.024)*x129))+(((-1.0)*x129*x135))+(((-1.0)*x130*x133)));
evalcond[4]=((((-0.128)*x129))+((x129*x133))+((sj3*x129*x131))+((x131*x138))+((x130*x132))+((x134*x139))+pz+(((0.024)*x130))+(((-1.0)*x130*x135)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x140=pz*pz;
CheckValue<IkReal> x143 = IKatan2WithCheck(IkReal(((0.256)*pz)),IkReal(((-0.048)*pz)),IKFAST_ATAN2_MAGTHRESH);
if(!x143.valid){
continue;
}
IkReal x141=((1.0)*(x143.value));
if((x140) < -0.00001)
continue;
CheckValue<IkReal> x144=IKPowWithIntegerCheck(IKabs(((16.2788205960997)*(IKsqrt(x140)))),-1);
if(!x144.valid){
continue;
}
if( (((62.5)*(x144.value)*(((0.014292)+(((0.031248)*cj3))+(((-1.0)*x140)))))) < -1-IKFAST_SINCOS_THRESH || (((62.5)*(x144.value)*(((0.014292)+(((0.031248)*cj3))+(((-1.0)*x140)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x142=IKasin(((62.5)*(x144.value)*(((0.014292)+(((0.031248)*cj3))+(((-1.0)*x140))))));
j1array[0]=((((-1.0)*x141))+(((-1.0)*x142)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x141))+x142);
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x145=(cj1*pz);
IkReal x146=((31500.0)*pz*sj1);
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=((IKabs(((-744.0)+(((-31000.0)*pz*sj1))+(((-31500.0)*sj3*x145))+(((-1.0)*cj3*x146))+(((4032.0)*sj3))+(((-756.0)*cj3)))))+(IKabs(((3968.0)+(((-31500.0)*cj3*x145))+(((4032.0)*cj3))+(((-31000.0)*x145))+((sj3*x146))+(((756.0)*sj3))))));
j2eval[2]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x147=cj1*cj1;
IkReal x148=(cj1*sj3);
IkReal x149=((7875.0)*pz);
IkReal x150=(cj1*sj1);
IkReal x151=((7750.0)*pz);
IkReal x152=(cj1*cj3);
j2eval[0]=((((1.00012800819252)*cj1))+x152);
j2eval[1]=((IKabs(((((-1.0)*sj3*x147*x149))+(((-1.0)*cj3*x149*x150))+(((-1.0)*x150*x151))+(((-189.0)*x152))+(((1008.0)*x148))+(((-186.0)*cj1)))))+(IKabs((((sj1*x148*x149))+(((992.0)*cj1))+(((1008.0)*x152))+(((-1.0)*x147*x151))+(((-1.0)*cj3*x147*x149))+(((189.0)*x148))))));
j2eval[2]=IKsign(((((15.626)*cj1))+(((15.624)*x152))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
px=0;
py=0;
pp=pz*pz;
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=IKsign(((0.750048)+(((0.749952)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x153=((31500.0)*pz);
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=((IKabs(((-744.0)+(((-31000.0)*pz))+(((-1.0)*cj3*x153))+(((4032.0)*sj3))+(((-756.0)*cj3)))))+(IKabs(((3968.0)+(((4032.0)*cj3))+((sj3*x153))+(((756.0)*sj3))))));
j2eval[2]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x154=pz*pz;
IkReal x155=((63.0)*x154);
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=((IKabs(((0.380928)+(((0.387072)*cj3))+(((0.972972)*sj3))+(((1.968624)*cj3*sj3))+(((-1.0)*sj3*x155)))))+(IKabs(((-0.957528)+(((-1.968624)*(cj3*cj3)))+(((62.0)*x154))+((cj3*x155))+(((0.387072)*sj3))+(((-2.910348)*cj3))))));
j2eval[2]=IKsign(((0.750048)+(((0.749952)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
px=0;
py=0;
pp=pz*pz;
sj1=1.0;
cj1=0;
j1=1.5707963267949;
j2eval[0]=((-1.00012800819252)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-4.000256)+(((-3.999744)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x156=pz*pz;
IkReal x157=(cj3*pz);
IkReal x158=(pz*sj3);
IkReal x159=((63.0)*x156);
CheckValue<IkReal> x160 = IKatan2WithCheck(IkReal(((-2.91772)+(((-16.128)*x158))+(((-1.968624)*(cj3*cj3)))+(((62.0)*x156))+((cj3*x159))+(((-4.902156)*cj3))+(((3.024)*x157))+(((2.976)*pz))+(((-0.387072)*sj3)))),IkReal(((0.380928)+(((-1.968624)*cj3*sj3))+(((0.387072)*cj3))+(((16.128)*x157))+(((-2.96478)*sj3))+(((3.024)*x158))+((sj3*x159))+(((15.872)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x160.valid){
continue;
}
CheckValue<IkReal> x161=IKPowWithIntegerCheck(IKsign(((-4.000256)+(((-3.999744)*cj3)))),-1);
if(!x161.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x160.value)+(((1.5707963267949)*(x161.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x162=IKsin(j2);
IkReal x163=IKcos(j2);
IkReal x164=(sj3*x162);
IkReal x165=(sj3*x163);
IkReal x166=(cj3*x162);
IkReal x167=(cj3*x163);
evalcond[0]=((-0.128)+(((0.126)*x165))+(((0.126)*x166))+(((0.124)*x162)));
evalcond[1]=((0.024)+pz+(((-0.126)*x164))+(((0.126)*x167))+(((0.124)*x163)));
evalcond[2]=((0.048212)+(((0.031248)*cj3))+(((0.005952)*x163))+(((-1.0)*(pz*pz)))+(((-0.006048)*x164))+(((-0.031744)*x162))+(((0.006048)*x167))+(((-0.032256)*x166))+(((-0.032256)*x165)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x168=pz*pz;
IkReal x169=((63.0)*x168);
CheckValue<IkReal> x170=IKPowWithIntegerCheck(IKsign(((0.750048)+(((0.749952)*cj3)))),-1);
if(!x170.valid){
continue;
}
CheckValue<IkReal> x171 = IKatan2WithCheck(IkReal(((0.380928)+(((0.387072)*cj3))+(((0.972972)*sj3))+(((1.968624)*cj3*sj3))+(((-1.0)*sj3*x169)))),IkReal(((-0.957528)+(((62.0)*x168))+(((-1.968624)*(cj3*cj3)))+(((0.387072)*sj3))+((cj3*x169))+(((-2.910348)*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x171.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x170.value)))+(x171.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x172=IKsin(j2);
IkReal x173=IKcos(j2);
IkReal x174=(sj3*x172);
IkReal x175=(sj3*x173);
IkReal x176=(cj3*x172);
IkReal x177=(cj3*x173);
evalcond[0]=((-0.128)+(((0.124)*x172))+(((0.126)*x176))+(((0.126)*x175)));
evalcond[1]=((0.024)+pz+(((-0.126)*x174))+(((0.124)*x173))+(((0.126)*x177)));
evalcond[2]=((0.048212)+(((0.031248)*cj3))+(((-0.006048)*x174))+(((0.005952)*x173))+(((-0.031744)*x172))+(((-1.0)*(pz*pz)))+(((-0.032256)*x176))+(((-0.032256)*x175))+(((0.006048)*x177)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x178=((31500.0)*pz);
CheckValue<IkReal> x179=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x179.valid){
continue;
}
CheckValue<IkReal> x180 = IKatan2WithCheck(IkReal(((3968.0)+(((4032.0)*cj3))+(((756.0)*sj3))+((sj3*x178)))),IkReal(((-744.0)+(((-31000.0)*pz))+(((-1.0)*cj3*x178))+(((4032.0)*sj3))+(((-756.0)*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x180.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x179.value)))+(x180.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x181=IKsin(j2);
IkReal x182=IKcos(j2);
IkReal x183=(sj3*x181);
IkReal x184=(sj3*x182);
IkReal x185=(cj3*x181);
IkReal x186=(cj3*x182);
evalcond[0]=((-0.128)+(((0.124)*x181))+(((0.126)*x185))+(((0.126)*x184)));
evalcond[1]=((0.024)+(((-0.126)*x183))+pz+(((0.124)*x182))+(((0.126)*x186)));
evalcond[2]=((0.048212)+(((0.005952)*x182))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-0.032256)*x184))+(((-0.032256)*x185))+(((-0.006048)*x183))+(((-0.031744)*x181))+(((0.006048)*x186)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x187=((31500.0)*pz);
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=((IKabs(((-744.0)+(((4032.0)*sj3))+(((31000.0)*pz))+((cj3*x187))+(((-756.0)*cj3)))))+(IKabs(((3968.0)+(((4032.0)*cj3))+(((-1.0)*sj3*x187))+(((756.0)*sj3))))));
j2eval[2]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x188=pz*pz;
IkReal x189=((63.0)*x188);
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=((IKabs(((0.380928)+(((0.387072)*cj3))+(((0.972972)*sj3))+(((1.968624)*cj3*sj3))+(((-1.0)*sj3*x189)))))+(IKabs(((-0.957528)+(((62.0)*x188))+(((-1.968624)*(cj3*cj3)))+(((0.387072)*sj3))+((cj3*x189))+(((-2.910348)*cj3))))));
j2eval[2]=IKsign(((0.750048)+(((0.749952)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
px=0;
py=0;
pp=pz*pz;
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
j2eval[0]=((-1.00012800819252)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-4.000256)+(((-3.999744)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x190=pz*pz;
IkReal x191=(cj3*pz);
IkReal x192=(pz*sj3);
IkReal x193=((63.0)*x190);
CheckValue<IkReal> x194 = IKatan2WithCheck(IkReal(((-2.91772)+(((16.128)*x192))+(((-3.024)*x191))+(((62.0)*x190))+(((-1.968624)*(cj3*cj3)))+(((-4.902156)*cj3))+((cj3*x193))+(((-0.387072)*sj3))+(((-2.976)*pz)))),IkReal(((0.380928)+(((-1.968624)*cj3*sj3))+(((0.387072)*cj3))+((sj3*x193))+(((-3.024)*x192))+(((-2.96478)*sj3))+(((-16.128)*x191))+(((-15.872)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x194.valid){
continue;
}
CheckValue<IkReal> x195=IKPowWithIntegerCheck(IKsign(((-4.000256)+(((-3.999744)*cj3)))),-1);
if(!x195.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x194.value)+(((1.5707963267949)*(x195.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x196=IKsin(j2);
IkReal x197=IKcos(j2);
IkReal x198=(sj3*x196);
IkReal x199=(sj3*x197);
IkReal x200=(cj3*x196);
IkReal x201=(cj3*x197);
evalcond[0]=((-0.128)+(((0.126)*x199))+(((0.126)*x200))+(((0.124)*x196)));
evalcond[1]=((0.024)+(((-1.0)*pz))+(((0.126)*x201))+(((-0.126)*x198))+(((0.124)*x197)));
evalcond[2]=((0.048212)+(((-0.032256)*x200))+(((0.031248)*cj3))+(((0.006048)*x201))+(((0.005952)*x197))+(((-0.032256)*x199))+(((-1.0)*(pz*pz)))+(((-0.006048)*x198))+(((-0.031744)*x196)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x202=pz*pz;
IkReal x203=((63.0)*x202);
CheckValue<IkReal> x204 = IKatan2WithCheck(IkReal(((0.380928)+(((0.387072)*cj3))+(((0.972972)*sj3))+(((1.968624)*cj3*sj3))+(((-1.0)*sj3*x203)))),IkReal(((-0.957528)+((cj3*x203))+(((-1.968624)*(cj3*cj3)))+(((0.387072)*sj3))+(((-2.910348)*cj3))+(((62.0)*x202)))),IKFAST_ATAN2_MAGTHRESH);
if(!x204.valid){
continue;
}
CheckValue<IkReal> x205=IKPowWithIntegerCheck(IKsign(((0.750048)+(((0.749952)*cj3)))),-1);
if(!x205.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x204.value)+(((1.5707963267949)*(x205.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x206=IKsin(j2);
IkReal x207=IKcos(j2);
IkReal x208=(sj3*x206);
IkReal x209=(sj3*x207);
IkReal x210=(cj3*x206);
IkReal x211=(cj3*x207);
evalcond[0]=((-0.128)+(((0.126)*x210))+(((0.126)*x209))+(((0.124)*x206)));
evalcond[1]=((0.024)+(((0.126)*x211))+(((-1.0)*pz))+(((0.124)*x207))+(((-0.126)*x208)));
evalcond[2]=((0.048212)+(((-0.032256)*x210))+(((0.005952)*x207))+(((-0.031744)*x206))+(((-0.032256)*x209))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-0.006048)*x208))+(((0.006048)*x211)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x212=((31500.0)*pz);
CheckValue<IkReal> x213=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x213.valid){
continue;
}
CheckValue<IkReal> x214 = IKatan2WithCheck(IkReal(((3968.0)+(((-1.0)*sj3*x212))+(((4032.0)*cj3))+(((756.0)*sj3)))),IkReal(((-744.0)+((cj3*x212))+(((4032.0)*sj3))+(((31000.0)*pz))+(((-756.0)*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x214.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x213.value)))+(x214.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x215=IKsin(j2);
IkReal x216=IKcos(j2);
IkReal x217=(sj3*x215);
IkReal x218=(sj3*x216);
IkReal x219=(cj3*x215);
IkReal x220=(cj3*x216);
evalcond[0]=((-0.128)+(((0.126)*x219))+(((0.126)*x218))+(((0.124)*x215)));
evalcond[1]=((0.024)+(((0.126)*x220))+(((-0.126)*x217))+(((0.124)*x216))+(((-1.0)*pz)));
evalcond[2]=((0.048212)+(((-0.032256)*x218))+(((-0.032256)*x219))+(((-0.006048)*x217))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.006048)*x220))+(((-0.031744)*x215))+(((0.005952)*x216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x221=pz*pz;
IkReal x222=(cj1*pz);
IkReal x223=((63.0)*x221);
CheckValue<IkReal> x224 = IKatan2WithCheck(IkReal(((0.380928)+(((0.387072)*cj3))+(((-2.976)*x222))+(((16.128)*sj3*x222))+(((-3.024)*cj3*x222))+(((0.972972)*sj3))+(((1.968624)*cj3*sj3))+(((-1.0)*sj3*x223)))),IkReal(((-0.957528)+(((-3.024)*sj3*x222))+((cj3*x223))+(((-1.968624)*(cj3*cj3)))+(((0.387072)*sj3))+(((62.0)*x221))+(((-15.872)*x222))+(((-2.910348)*cj3))+(((-16.128)*cj3*x222)))),IKFAST_ATAN2_MAGTHRESH);
if(!x224.valid){
continue;
}
CheckValue<IkReal> x225=IKPowWithIntegerCheck(IKsign(((0.750048)+(((0.749952)*cj3)))),-1);
if(!x225.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x224.value)+(((1.5707963267949)*(x225.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x226=IKsin(j2);
IkReal x227=IKcos(j2);
IkReal x228=((0.126)*cj3);
IkReal x229=((0.126)*sj1);
IkReal x230=(cj1*x226);
IkReal x231=(sj3*x226);
IkReal x232=(sj3*x227);
IkReal x233=((0.124)*x227);
IkReal x234=(sj1*x226);
evalcond[0]=((-0.128)+(((0.124)*x226))+((cj1*pz))+(((0.126)*x232))+((x226*x228)));
evalcond[1]=((0.024)+((x227*x228))+x233+(((-0.126)*x231))+((pz*sj1)));
evalcond[2]=((0.048212)+(((-0.032256)*x232))+(((0.005952)*x227))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.006048)*cj3*x227))+(((-0.006048)*x231))+(((-0.032256)*cj3*x226))+(((-0.031744)*x226)));
evalcond[3]=(((cj1*x233))+(((0.128)*sj1))+(((0.024)*cj1))+((cj1*x227*x228))+(((-1.0)*x229*x232))+(((-0.126)*sj3*x230))+(((-1.0)*x228*x234))+(((-0.124)*x234)));
evalcond[4]=(((sj1*x233))+((x228*x230))+(((-0.128)*cj1))+(((0.024)*sj1))+(((0.124)*x230))+pz+(((0.126)*cj1*x232))+(((-1.0)*x229*x231))+((sj1*x227*x228)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x235=cj1*cj1;
IkReal x236=(cj1*cj3);
IkReal x237=(pz*sj1);
IkReal x238=(cj1*sj3);
IkReal x239=(pz*x235);
CheckValue<IkReal> x240=IKPowWithIntegerCheck(IKsign(((((15.624)*x236))+(((15.626)*cj1)))),-1);
if(!x240.valid){
continue;
}
CheckValue<IkReal> x241 = IKatan2WithCheck(IkReal(((((1.512)*x238))+(((7.936)*cj1))+(((-63.0)*cj3*x239))+(((63.0)*x237*x238))+(((-62.0)*x239))+(((8.064)*x236)))),IkReal(((((-63.0)*x236*x237))+(((-1.488)*cj1))+(((-63.0)*sj3*x239))+(((-62.0)*cj1*x237))+(((-1.512)*x236))+(((8.064)*x238)))),IKFAST_ATAN2_MAGTHRESH);
if(!x241.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x240.value)))+(x241.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x242=IKsin(j2);
IkReal x243=IKcos(j2);
IkReal x244=((0.126)*cj3);
IkReal x245=((0.126)*sj1);
IkReal x246=(cj1*x242);
IkReal x247=(sj3*x242);
IkReal x248=(sj3*x243);
IkReal x249=((0.124)*x243);
IkReal x250=(sj1*x242);
evalcond[0]=((-0.128)+(((0.124)*x242))+((cj1*pz))+((x242*x244))+(((0.126)*x248)));
evalcond[1]=((0.024)+x249+((pz*sj1))+((x243*x244))+(((-0.126)*x247)));
evalcond[2]=((0.048212)+(((0.005952)*x243))+(((-0.032256)*cj3*x242))+(((0.006048)*cj3*x243))+(((0.031248)*cj3))+(((-0.006048)*x247))+(((-1.0)*(pz*pz)))+(((-0.031744)*x242))+(((-0.032256)*x248)));
evalcond[3]=((((0.128)*sj1))+((cj1*x243*x244))+(((0.024)*cj1))+(((-1.0)*x244*x250))+((cj1*x249))+(((-0.126)*sj3*x246))+(((-1.0)*x245*x248))+(((-0.124)*x250)));
evalcond[4]=((((-0.128)*cj1))+(((0.124)*x246))+(((0.024)*sj1))+((x244*x246))+(((0.126)*cj1*x248))+pz+((sj1*x243*x244))+(((-1.0)*x245*x247))+((sj1*x249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x251=(cj1*pz);
IkReal x252=((31500.0)*pz*sj1);
CheckValue<IkReal> x253=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x253.valid){
continue;
}
CheckValue<IkReal> x254 = IKatan2WithCheck(IkReal(((3968.0)+(((-31000.0)*x251))+((sj3*x252))+(((4032.0)*cj3))+(((-31500.0)*cj3*x251))+(((756.0)*sj3)))),IkReal(((-744.0)+(((-31500.0)*sj3*x251))+(((-31000.0)*pz*sj1))+(((4032.0)*sj3))+(((-1.0)*cj3*x252))+(((-756.0)*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x254.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x253.value)))+(x254.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x255=IKsin(j2);
IkReal x256=IKcos(j2);
IkReal x257=((0.126)*cj3);
IkReal x258=((0.126)*sj1);
IkReal x259=(cj1*x255);
IkReal x260=(sj3*x255);
IkReal x261=(sj3*x256);
IkReal x262=((0.124)*x256);
IkReal x263=(sj1*x255);
evalcond[0]=((-0.128)+((cj1*pz))+((x255*x257))+(((0.126)*x261))+(((0.124)*x255)));
evalcond[1]=((0.024)+((x256*x257))+x262+((pz*sj1))+(((-0.126)*x260)));
evalcond[2]=((0.048212)+(((-0.006048)*x260))+(((0.031248)*cj3))+(((0.005952)*x256))+(((0.006048)*cj3*x256))+(((-1.0)*(pz*pz)))+(((-0.032256)*x261))+(((-0.032256)*cj3*x255))+(((-0.031744)*x255)));
evalcond[3]=((((0.128)*sj1))+(((-1.0)*x258*x261))+(((-0.126)*sj3*x259))+(((0.024)*cj1))+((cj1*x262))+((cj1*x256*x257))+(((-0.124)*x263))+(((-1.0)*x257*x263)));
evalcond[4]=((((-1.0)*x258*x260))+(((-0.128)*cj1))+(((0.024)*sj1))+((x257*x259))+((sj1*x256*x257))+(((0.126)*cj1*x261))+pz+((sj1*x262))+(((0.124)*x259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x264=((0.005952)+(((0.006048)*cj3))+(((-0.032256)*sj3)));
IkReal x265=((-0.031744)+(((-0.032256)*cj3))+(((-0.006048)*sj3)));
CheckValue<IkReal> x268 = IKatan2WithCheck(IkReal(x264),IkReal(x265),IKFAST_ATAN2_MAGTHRESH);
if(!x268.valid){
continue;
}
IkReal x266=((1.0)*(x268.value));
if((((x264*x264)+(x265*x265))) < -0.00001)
continue;
CheckValue<IkReal> x269=IKPowWithIntegerCheck(IKabs(IKsqrt(((x264*x264)+(x265*x265)))),-1);
if(!x269.valid){
continue;
}
if( (((x269.value)*(((0.048212)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x269.value)*(((0.048212)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x267=IKasin(((x269.value)*(((0.048212)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j2array[0]=((((-1.0)*x267))+(((-1.0)*x266)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+x267+(((-1.0)*x266)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x270=cj2*cj2;
IkReal x271=cj3*cj3;
IkReal x272=sj2*sj2;
IkReal x273=sj3*sj3;
IkReal x274=((0.126)*cj3);
IkReal x275=(sj2*sj3);
IkReal x276=(cj2*sj3);
IkReal x277=((5.25)*cj3);
IkReal x278=((2.66733870967742)*x270);
IkReal x279=((2.66733870967742)*x272);
j1eval[0]=((IKabs(((0.024)+(((0.124)*cj2))+((cj2*x274))+(((-0.126)*x275)))))+(IKabs(((-0.128)+((sj2*x274))+(((0.124)*sj2))+(((0.126)*x276))))));
j1eval[1]=((2.8494623655914)+((x272*x277))+((x273*x278))+((x273*x279))+(((-1.01612903225806)*x275))+(((-5.41935483870968)*x276))+((x271*x279))+((x271*x278))+(((-5.41935483870968)*cj3*sj2))+cj2+(((2.58333333333333)*x272))+(((2.58333333333333)*x270))+(((1.01612903225806)*cj2*cj3))+((x270*x277))+(((-5.33333333333333)*sj2)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x280=((0.126)*sj2);
IkReal x281=((0.126)*cj2);
j1eval[0]=pz;
j1eval[1]=((IKabs(((-0.024)+(((-1.0)*cj3*x281))+((sj3*x280))+(((-0.124)*cj2)))))+(IKabs(((0.128)+(((-1.0)*sj3*x281))+(((-1.0)*cj3*x280))+(((-0.124)*sj2))))));
j1eval[2]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
px=0;
py=0;
pp=pz*pz;
IkReal x282=((1.01612903225806)*pz);
j1eval[0]=((((-1.0)*cj3*sj2*x282))+(((-1.0)*pz*sj2))+(((1.03225806451613)*pz))+(((-1.0)*cj2*sj3*x282)));
j1eval[1]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x283=((0.126)*sj3);
j1eval[0]=((IKabs(((-0.128)+(((0.0663709677419355)*sj2))+((cj2*x283)))))+(IKabs(((0.024)+(((-1.0)*sj2*x283))+(((0.0663709677419355)*cj2))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x284=((0.126)*sj3);
j1eval[0]=((IKabs(((0.024)+(((-1.0)*sj2*x284))+(((0.0663709677419355)*cj2)))))+(IKabs(((0.128)+(((-1.0)*cj2*x284))+(((-0.0663709677419355)*sj2))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x285=((0.126)*sj3);
CheckValue<IkReal> x287 = IKatan2WithCheck(IkReal(((0.024)+(((-1.0)*sj2*x285))+(((0.0663709677419355)*cj2)))),IkReal(((0.128)+(((-1.0)*cj2*x285))+(((-0.0663709677419355)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x287.valid){
continue;
}
IkReal x286=x287.value;
j1array[0]=((-1.0)*x286);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x286)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x288=IKcos(j1);
IkReal x289=IKsin(j1);
IkReal x290=((0.126)*sj3);
evalcond[0]=((((-1.0)*sj2*x289*x290))+(((0.0663709677419355)*sj2*x288))+(((0.024)*x289))+(((-0.128)*x288))+(((0.0663709677419355)*cj2*x289))+((cj2*x288*x290)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x291=((0.126)*sj3);
CheckValue<IkReal> x293 = IKatan2WithCheck(IkReal(((-0.128)+((cj2*x291))+(((0.0663709677419355)*sj2)))),IkReal(((0.024)+(((0.0663709677419355)*cj2))+(((-1.0)*sj2*x291)))),IKFAST_ATAN2_MAGTHRESH);
if(!x293.valid){
continue;
}
IkReal x292=x293.value;
j1array[0]=((-1.0)*x292);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x292)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x294=IKcos(j1);
IkReal x295=IKsin(j1);
IkReal x296=((0.126)*sj3);
evalcond[0]=((((0.0663709677419355)*cj2*x294))+(((-0.0663709677419355)*sj2*x295))+(((-1.0)*sj2*x294*x296))+(((-1.0)*cj2*x295*x296))+(((0.024)*x294))+(((0.128)*x295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x297=cj2*cj2;
IkReal x298=(cj3*sj2);
IkReal x299=((0.126)*pz);
IkReal x300=(cj3*sj3);
IkReal x301=((0.124)*sj2);
IkReal x302=(cj2*sj2);
IkReal x303=(cj2*sj3);
CheckValue<IkReal> x304=IKPowWithIntegerCheck(((((-1.0)*x298*x299))+(((-1.0)*x299*x303))+(((-1.0)*pz*x301))+(((0.128)*pz))),-1);
if(!x304.valid){
continue;
}
CheckValue<IkReal> x305=IKPowWithIntegerCheck(pz,-1);
if(!x305.valid){
continue;
}
if( IKabs(((x304.value)*(((-0.003072)+(((0.031248)*sj3*x297))+(((-0.015624)*sj3))+(((-0.0005)*x302))+(((-0.015872)*cj2))+(((0.031752)*x297*x300))+(((0.003024)*x298))+(((0.003024)*x303))+(((-0.015876)*x300))+(((-0.016128)*cj2*cj3))+(((0.002976)*sj2))+(((0.016128)*sj2*sj3))+(((0.031248)*cj2*x298))+(((0.031752)*cj2*cj3*x298)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x305.value)*(((0.128)+(((-0.126)*x303))+(((-0.126)*x298))+(((-1.0)*x301)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x304.value)*(((-0.003072)+(((0.031248)*sj3*x297))+(((-0.015624)*sj3))+(((-0.0005)*x302))+(((-0.015872)*cj2))+(((0.031752)*x297*x300))+(((0.003024)*x298))+(((0.003024)*x303))+(((-0.015876)*x300))+(((-0.016128)*cj2*cj3))+(((0.002976)*sj2))+(((0.016128)*sj2*sj3))+(((0.031248)*cj2*x298))+(((0.031752)*cj2*cj3*x298))))))+IKsqr(((x305.value)*(((0.128)+(((-0.126)*x303))+(((-0.126)*x298))+(((-1.0)*x301))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x304.value)*(((-0.003072)+(((0.031248)*sj3*x297))+(((-0.015624)*sj3))+(((-0.0005)*x302))+(((-0.015872)*cj2))+(((0.031752)*x297*x300))+(((0.003024)*x298))+(((0.003024)*x303))+(((-0.015876)*x300))+(((-0.016128)*cj2*cj3))+(((0.002976)*sj2))+(((0.016128)*sj2*sj3))+(((0.031248)*cj2*x298))+(((0.031752)*cj2*cj3*x298))))), ((x305.value)*(((0.128)+(((-0.126)*x303))+(((-0.126)*x298))+(((-1.0)*x301))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x306=IKcos(j1);
IkReal x307=IKsin(j1);
IkReal x308=((0.126)*cj2);
IkReal x309=((0.124)*cj2);
IkReal x310=((0.124)*sj2);
IkReal x311=((0.126)*sj2);
IkReal x312=(sj3*x311);
IkReal x313=(pz*x307);
IkReal x314=(pz*x306);
IkReal x315=(cj3*x307);
IkReal x316=(cj3*x306);
evalcond[0]=((-0.128)+((sj3*x308))+x314+x310+((cj3*x311)));
evalcond[1]=((0.024)+x309+x313+((cj3*x308))+(((-1.0)*x312)));
evalcond[2]=((0.014292)+(((-0.048)*x313))+(((0.256)*x314))+(((0.031248)*cj3))+(((-1.0)*(pz*pz))));
evalcond[3]=((((0.024)*x306))+((x308*x316))+(((-1.0)*x306*x312))+(((0.128)*x307))+(((-1.0)*x307*x310))+(((-1.0)*sj3*x307*x308))+(((-1.0)*x311*x315))+((x306*x309)));
evalcond[4]=((((0.024)*x307))+((x308*x315))+((x306*x310))+pz+((x311*x316))+(((-0.128)*x306))+(((-1.0)*x307*x312))+((sj3*x306*x308))+((x307*x309)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x320=IKPowWithIntegerCheck(pz,-1);
if(!x320.valid){
continue;
}
IkReal x317=x320.value;
IkReal x318=(cj3*sj2);
IkReal x319=(cj2*sj3);
CheckValue<IkReal> x321=IKPowWithIntegerCheck(x317,-2);
if(!x321.valid){
continue;
}
if( IKabs(((0.166666666666667)*x317*(((5.8825)+(((3.906)*cj3))+(((-4.032)*x318))+(((-4.032)*x319))+(((-125.0)*(x321.value)))+(((-3.968)*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x317*(((0.128)+(((-0.124)*sj2))+(((-0.126)*x319))+(((-0.126)*x318)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.166666666666667)*x317*(((5.8825)+(((3.906)*cj3))+(((-4.032)*x318))+(((-4.032)*x319))+(((-125.0)*(x321.value)))+(((-3.968)*sj2))))))+IKsqr((x317*(((0.128)+(((-0.124)*sj2))+(((-0.126)*x319))+(((-0.126)*x318))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.166666666666667)*x317*(((5.8825)+(((3.906)*cj3))+(((-4.032)*x318))+(((-4.032)*x319))+(((-125.0)*(x321.value)))+(((-3.968)*sj2))))), (x317*(((0.128)+(((-0.124)*sj2))+(((-0.126)*x319))+(((-0.126)*x318))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x322=IKcos(j1);
IkReal x323=IKsin(j1);
IkReal x324=((0.126)*cj2);
IkReal x325=((0.124)*cj2);
IkReal x326=((0.124)*sj2);
IkReal x327=((0.126)*sj2);
IkReal x328=(sj3*x327);
IkReal x329=(pz*x323);
IkReal x330=(pz*x322);
IkReal x331=(cj3*x323);
IkReal x332=(cj3*x322);
evalcond[0]=((-0.128)+((sj3*x324))+x330+x326+((cj3*x327)));
evalcond[1]=((0.024)+(((-1.0)*x328))+x325+x329+((cj3*x324)));
evalcond[2]=((0.014292)+(((-0.048)*x329))+(((0.031248)*cj3))+(((0.256)*x330))+(((-1.0)*(pz*pz))));
evalcond[3]=(((x322*x325))+(((0.128)*x323))+((x324*x332))+(((-1.0)*x322*x328))+(((0.024)*x322))+(((-1.0)*x323*x326))+(((-1.0)*sj3*x323*x324))+(((-1.0)*x327*x331)));
evalcond[4]=(((x322*x326))+((x323*x325))+((sj3*x322*x324))+((x324*x331))+(((0.024)*x323))+(((-1.0)*x323*x328))+((x327*x332))+pz+(((-0.128)*x322)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x333=((0.126)*sj2);
IkReal x334=((0.126)*cj2);
CheckValue<IkReal> x335=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x335.valid){
continue;
}
CheckValue<IkReal> x336 = IKatan2WithCheck(IkReal(((-0.024)+((sj3*x333))+(((-0.124)*cj2))+(((-1.0)*cj3*x334)))),IkReal(((0.128)+(((-1.0)*sj3*x334))+(((-0.124)*sj2))+(((-1.0)*cj3*x333)))),IKFAST_ATAN2_MAGTHRESH);
if(!x336.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x335.value)))+(x336.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x337=IKcos(j1);
IkReal x338=IKsin(j1);
IkReal x339=((0.126)*cj2);
IkReal x340=((0.124)*cj2);
IkReal x341=((0.124)*sj2);
IkReal x342=((0.126)*sj2);
IkReal x343=(sj3*x342);
IkReal x344=(pz*x338);
IkReal x345=(pz*x337);
IkReal x346=(cj3*x338);
IkReal x347=(cj3*x337);
evalcond[0]=((-0.128)+((sj3*x339))+x341+x345+((cj3*x342)));
evalcond[1]=((0.024)+((cj3*x339))+x340+x344+(((-1.0)*x343)));
evalcond[2]=((0.014292)+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.256)*x345))+(((-0.048)*x344)));
evalcond[3]=((((0.024)*x337))+((x337*x340))+(((-1.0)*x337*x343))+(((0.128)*x338))+(((-1.0)*sj3*x338*x339))+(((-1.0)*x338*x341))+((x339*x347))+(((-1.0)*x342*x346)));
evalcond[4]=((((0.024)*x338))+((x337*x341))+((sj3*x337*x339))+(((-0.128)*x337))+pz+((x338*x340))+(((-1.0)*x338*x343))+((x339*x346))+((x342*x347)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x348=((0.126)*cj3);
IkReal x349=((0.126)*sj3);
IkReal x350=((0.024)+(((0.124)*cj2))+((cj2*x348))+(((-1.0)*sj2*x349)));
IkReal x351=((-0.128)+((sj2*x348))+(((0.124)*sj2))+((cj2*x349)));
CheckValue<IkReal> x354 = IKatan2WithCheck(IkReal(x351),IkReal(x350),IKFAST_ATAN2_MAGTHRESH);
if(!x354.valid){
continue;
}
IkReal x352=((1.0)*(x354.value));
if((((x350*x350)+(x351*x351))) < -0.00001)
continue;
CheckValue<IkReal> x355=IKPowWithIntegerCheck(IKabs(IKsqrt(((x350*x350)+(x351*x351)))),-1);
if(!x355.valid){
continue;
}
if( ((pz*(x355.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x355.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x353=IKasin((pz*(x355.value)));
j1array[0]=((((-1.0)*x352))+(((-1.0)*x353)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x352))+x353);
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
IkReal x356=((62.0)*cj2);
IkReal x357=((63.0)*cj2*cj3);
IkReal x358=((500.0)*pz*sj1);
IkReal x359=((63.0)*sj2*sj3);
IkReal x360=(((cj1*(px*px)))+((cj1*(py*py))));
j0eval[0]=x360;
j0eval[1]=((IKabs(((((12.0)*py))+((py*x356))+((py*x357))+((py*x358))+(((-1.0)*py*x359)))))+(IKabs((((px*x358))+((px*x356))+((px*x357))+(((12.0)*px))+(((-1.0)*px*x359))))));
j0eval[2]=IKsign(x360);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x361=(px*sj2);
IkReal x362=((63.0)*cj3);
IkReal x363=(py*sj2);
IkReal x364=((500.0)*cj1*pz);
IkReal x365=((63.0)*cj2*sj3);
IkReal x366=(((sj1*(py*py)))+((sj1*(px*px))));
j0eval[0]=x366;
j0eval[1]=IKsign(x366);
j0eval[2]=((IKabs(((((-1.0)*x361*x362))+(((64.0)*px))+(((-62.0)*x361))+(((-1.0)*px*x365))+(((-1.0)*px*x364)))))+(IKabs(((((-1.0)*x362*x363))+(((64.0)*py))+(((-62.0)*x363))+(((-1.0)*py*x364))+(((-1.0)*py*x365))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x367=((px*px)+(py*py));
j0eval[0]=x367;
j0eval[1]=IKsign(x367);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x368=((62.0)*cj2);
IkReal x369=((63.0)*cj2*cj3);
IkReal x370=((63.0)*sj2*sj3);
IkReal x371=((px*px)+(py*py));
j0eval[0]=x371;
j0eval[1]=IKsign(x371);
j0eval[2]=((IKabs(((((12.0)*px))+((px*x368))+((px*x369))+(((-1.0)*px*x370)))))+(IKabs(((((12.0)*py))+((py*x369))+((py*x368))+(((-1.0)*py*x370))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x372=px*px;
IkReal x373=py*py;
IkReal x374=pz*pz;
IkReal x375=((64000.0)*pz);
IkReal x376=((7812.0)*cj3);
IkReal x377=((250000.0)*x374);
j0eval[0]=((((-1.0)*x373))+(((-1.0)*x372)));
j0eval[1]=((IKabs(((((-250000.0)*px*x373))+((px*x375))+((px*x376))+(((3573.0)*px))+(((-250000.0)*(px*px*px)))+(((-1.0)*px*x377)))))+(IKabs((((py*x375))+((py*x376))+(((-250000.0)*(py*py*py)))+(((3573.0)*py))+(((-250000.0)*py*x372))+(((-1.0)*py*x377))))));
j0eval[2]=IKsign(((((-6.0)*x372))+(((-6.0)*x373))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x378=pz*pz;
IkReal x379=px*px;
IkReal x380=py*py;
IkReal x381=((32.0)*pz);
IkReal x382=((125.0)*py);
IkReal x383=((125.0)*px);
IkReal x384=((3.906)*cj3);
CheckValue<IkReal> x385=IKPowWithIntegerCheck(IKsign(((((-6.0)*x380))+(((-6.0)*x379)))),-1);
if(!x385.valid){
continue;
}
CheckValue<IkReal> x386 = IKatan2WithCheck(IkReal(((((-1.0)*x379*x382))+(((-1.0)*x382*(py*py)))+(((-1.0)*x378*x382))+(((1.7865)*py))+((py*x384))+((py*x381)))),IkReal((((px*x384))+((px*x381))+(((-1.0)*x383*(px*px)))+(((-1.0)*x380*x383))+(((-1.0)*x378*x383))+(((1.7865)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x386.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x385.value)))+(x386.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x387=IKcos(j0);
IkReal x388=IKsin(j0);
IkReal x389=((1.0)*x387);
IkReal x390=(py*x388);
evalcond[0]=((((-1.0)*py*x389))+((px*x388)));
evalcond[1]=((0.024)+(((0.126)*cj2*cj3))+(((-1.0)*x390))+(((0.124)*cj2))+(((-1.0)*px*x389))+(((-0.126)*sj2*sj3)));
evalcond[2]=((0.014292)+(((-1.0)*(px*px)))+(((0.048)*px*x387))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.048)*x390))+(((-1.0)*(py*py)))+(((0.256)*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x391=((0.124)*cj2);
IkReal x392=((0.126)*sj2*sj3);
IkReal x393=((0.126)*cj2*cj3);
CheckValue<IkReal> x394 = IKatan2WithCheck(IkReal((((py*x393))+((py*x391))+(((-1.0)*py*x392))+(((0.024)*py)))),IkReal((((px*x391))+((px*x393))+(((0.024)*px))+(((-1.0)*px*x392)))),IKFAST_ATAN2_MAGTHRESH);
if(!x394.valid){
continue;
}
CheckValue<IkReal> x395=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x395.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x394.value)+(((1.5707963267949)*(x395.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x396=IKcos(j0);
IkReal x397=IKsin(j0);
IkReal x398=((1.0)*x396);
IkReal x399=(py*x397);
evalcond[0]=(((px*x397))+(((-1.0)*py*x398)));
evalcond[1]=((0.024)+(((0.126)*cj2*cj3))+(((-1.0)*x399))+(((0.124)*cj2))+(((-0.126)*sj2*sj3))+(((-1.0)*px*x398)));
evalcond[2]=((0.014292)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((0.048)*px*x396))+(((-1.0)*(pz*pz)))+(((0.048)*x399))+(((-1.0)*(py*py)))+(((0.256)*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x400=((63.0)*py);
IkReal x401=(sj2*sj3);
IkReal x402=(cj2*cj3);
IkReal x403=((63.0)*px);
IkReal x404=((62.0)*cj2);
IkReal x405=((((-1.0)*(px*px)))+(((-1.0)*(py*py))));
j0eval[0]=x405;
j0eval[1]=IKsign(x405);
j0eval[2]=((IKabs(((((12.0)*px))+((px*x404))+(((-1.0)*x401*x403))+((x402*x403)))))+(IKabs((((py*x404))+(((12.0)*py))+(((-1.0)*x400*x401))+((x400*x402))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x406=px*px;
IkReal x407=py*py;
IkReal x408=pz*pz;
IkReal x409=((64000.0)*pz);
IkReal x410=((7812.0)*cj3);
IkReal x411=((250000.0)*x408);
j0eval[0]=(x407+x406);
j0eval[1]=IKsign(((((6.0)*x407))+(((6.0)*x406))));
j0eval[2]=((IKabs(((((-1.0)*px*x411))+(((-1.0)*px*x409))+((px*x410))+(((-250000.0)*px*x407))+(((3573.0)*px))+(((-250000.0)*(px*px*px))))))+(IKabs((((py*x410))+(((-250000.0)*(py*py*py)))+(((-250000.0)*py*x406))+(((3573.0)*py))+(((-1.0)*py*x411))+(((-1.0)*py*x409))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x412=px*px;
IkReal x413=py*py;
IkReal x414=pz*pz;
IkReal x415=((125.0)*px);
IkReal x416=((32.0)*pz);
IkReal x417=((125.0)*py);
IkReal x418=((3.906)*cj3);
CheckValue<IkReal> x419=IKPowWithIntegerCheck(IKsign(((((6.0)*x412))+(((6.0)*x413)))),-1);
if(!x419.valid){
continue;
}
CheckValue<IkReal> x420 = IKatan2WithCheck(IkReal((((py*x418))+(((-1.0)*x412*x417))+(((-1.0)*x417*(py*py)))+(((-1.0)*py*x416))+(((-1.0)*x414*x417))+(((1.7865)*py)))),IkReal(((((-1.0)*x415*(px*px)))+(((-1.0)*px*x416))+((px*x418))+(((-1.0)*x413*x415))+(((-1.0)*x414*x415))+(((1.7865)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x420.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x419.value)))+(x420.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x421=IKsin(j0);
IkReal x422=IKcos(j0);
IkReal x423=(py*x421);
IkReal x424=(px*x422);
evalcond[0]=((((-1.0)*py*x422))+((px*x421)));
evalcond[1]=((0.024)+(((0.126)*cj2*cj3))+(((0.124)*cj2))+x424+x423+(((-0.126)*sj2*sj3)));
evalcond[2]=((0.014292)+(((-1.0)*(px*px)))+(((-0.256)*pz))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-0.048)*x424))+(((-0.048)*x423)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x425=((0.124)*cj2);
IkReal x426=((0.126)*sj2*sj3);
IkReal x427=((0.126)*cj2*cj3);
CheckValue<IkReal> x428=IKPowWithIntegerCheck(IKsign(((((-1.0)*(px*px)))+(((-1.0)*(py*py))))),-1);
if(!x428.valid){
continue;
}
CheckValue<IkReal> x429 = IKatan2WithCheck(IkReal((((py*x427))+((py*x425))+(((0.024)*py))+(((-1.0)*py*x426)))),IkReal(((((-1.0)*px*x426))+(((0.024)*px))+((px*x425))+((px*x427)))),IKFAST_ATAN2_MAGTHRESH);
if(!x429.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x428.value)))+(x429.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x430=IKsin(j0);
IkReal x431=IKcos(j0);
IkReal x432=(py*x430);
IkReal x433=(px*x431);
evalcond[0]=(((px*x430))+(((-1.0)*py*x431)));
evalcond[1]=((0.024)+(((0.126)*cj2*cj3))+(((0.124)*cj2))+x432+x433+(((-0.126)*sj2*sj3)));
evalcond[2]=((0.014292)+(((-0.048)*x433))+(((-0.048)*x432))+(((-1.0)*(px*px)))+(((-0.256)*pz))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x434=(px*sj2);
IkReal x435=((63.0)*cj3);
IkReal x436=(py*sj2);
IkReal x437=((63.0)*cj2*sj3);
IkReal x438=((((-1.0)*(px*px)))+(((-1.0)*(py*py))));
j0eval[0]=x438;
j0eval[1]=((IKabs((((py*x437))+(((62.0)*x436))+(((-64.0)*py))+((x435*x436)))))+(IKabs((((px*x437))+((x434*x435))+(((62.0)*x434))+(((-64.0)*px))))));
j0eval[2]=IKsign(x438);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x439=px*px;
IkReal x440=py*py;
IkReal x441=pz*pz;
IkReal x442=((12000.0)*pz);
IkReal x443=((7812.0)*cj3);
IkReal x444=((250000.0)*x441);
j0eval[0]=((((-1.0)*x439))+(((-1.0)*x440)));
j0eval[1]=((IKabs((((px*x443))+(((-250000.0)*px*x440))+(((3573.0)*px))+(((-1.0)*px*x442))+(((-1.0)*px*x444))+(((-250000.0)*(px*px*px))))))+(IKabs((((py*x443))+(((-250000.0)*py*x439))+(((-250000.0)*(py*py*py)))+(((-1.0)*py*x442))+(((-1.0)*py*x444))+(((3573.0)*py))))));
j0eval[2]=IKsign(((((-32.0)*x440))+(((-32.0)*x439))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x445=pz*pz;
IkReal x446=py*py;
IkReal x447=px*px;
IkReal x448=((6.0)*pz);
IkReal x449=((125.0)*py);
IkReal x450=((125.0)*px);
IkReal x451=((3.906)*cj3);
CheckValue<IkReal> x452 = IKatan2WithCheck(IkReal(((((-1.0)*x445*x449))+(((-1.0)*x447*x449))+(((-1.0)*py*x448))+(((1.7865)*py))+((py*x451))+(((-1.0)*x449*(py*py))))),IkReal(((((-1.0)*x446*x450))+(((-1.0)*x450*(px*px)))+((px*x451))+(((-1.0)*x445*x450))+(((1.7865)*px))+(((-1.0)*px*x448)))),IKFAST_ATAN2_MAGTHRESH);
if(!x452.valid){
continue;
}
CheckValue<IkReal> x453=IKPowWithIntegerCheck(IKsign(((((-32.0)*x446))+(((-32.0)*x447)))),-1);
if(!x453.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x452.value)+(((1.5707963267949)*(x453.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x454=IKsin(j0);
IkReal x455=IKcos(j0);
IkReal x456=(px*x455);
IkReal x457=(py*x454);
evalcond[0]=((((-1.0)*py*x455))+((px*x454)));
evalcond[1]=((-0.128)+(((0.126)*cj2*sj3))+(((0.124)*sj2))+x456+x457+(((0.126)*cj3*sj2)));
evalcond[2]=((0.014292)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-0.048)*pz))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((0.256)*x457))+(((0.256)*x456)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x458=(px*sj2);
IkReal x459=((0.126)*cj3);
IkReal x460=(py*sj2);
IkReal x461=((0.126)*cj2*sj3);
CheckValue<IkReal> x462=IKPowWithIntegerCheck(IKsign(((((-1.0)*(px*px)))+(((-1.0)*(py*py))))),-1);
if(!x462.valid){
continue;
}
CheckValue<IkReal> x463 = IKatan2WithCheck(IkReal(((((0.124)*x460))+(((-0.128)*py))+((x459*x460))+((py*x461)))),IkReal(((((0.124)*x458))+(((-0.128)*px))+((px*x461))+((x458*x459)))),IKFAST_ATAN2_MAGTHRESH);
if(!x463.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x462.value)))+(x463.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x464=IKsin(j0);
IkReal x465=IKcos(j0);
IkReal x466=(px*x465);
IkReal x467=(py*x464);
evalcond[0]=((((-1.0)*py*x465))+((px*x464)));
evalcond[1]=((-0.128)+(((0.126)*cj2*sj3))+(((0.124)*sj2))+x467+x466+(((0.126)*cj3*sj2)));
evalcond[2]=((0.014292)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-0.048)*pz))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((0.256)*x466))+(((0.256)*x467)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x468=(px*sj2);
IkReal x469=((63.0)*cj3);
IkReal x470=(py*sj2);
IkReal x471=((63.0)*cj2*sj3);
IkReal x472=((px*px)+(py*py));
j0eval[0]=x472;
j0eval[1]=((IKabs((((x469*x470))+(((-64.0)*py))+((py*x471))+(((62.0)*x470)))))+(IKabs((((x468*x469))+(((62.0)*x468))+(((-64.0)*px))+((px*x471))))));
j0eval[2]=IKsign(x472);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x473=py*py;
IkReal x474=px*px;
IkReal x475=pz*pz;
IkReal x476=((12000.0)*pz);
IkReal x477=((7812.0)*cj3);
IkReal x478=((250000.0)*x475);
j0eval[0]=(x474+x473);
j0eval[1]=IKsign(((((32.0)*x473))+(((32.0)*x474))));
j0eval[2]=((IKabs(((((-250000.0)*py*x474))+(((-1.0)*py*x478))+(((-250000.0)*(py*py*py)))+((py*x476))+((py*x477))+(((3573.0)*py)))))+(IKabs(((((-250000.0)*px*x473))+(((-1.0)*px*x478))+(((3573.0)*px))+((px*x477))+((px*x476))+(((-250000.0)*(px*px*px)))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x479=pz*pz;
IkReal x480=py*py;
IkReal x481=px*px;
IkReal x482=((6.0)*pz);
IkReal x483=((125.0)*py);
IkReal x484=((125.0)*px);
IkReal x485=((3.906)*cj3);
CheckValue<IkReal> x486 = IKatan2WithCheck(IkReal((((py*x485))+((py*x482))+(((-1.0)*x481*x483))+(((-1.0)*x479*x483))+(((-1.0)*x483*(py*py)))+(((1.7865)*py)))),IkReal((((px*x485))+((px*x482))+(((-1.0)*x480*x484))+(((-1.0)*x479*x484))+(((-1.0)*x484*(px*px)))+(((1.7865)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x486.valid){
continue;
}
CheckValue<IkReal> x487=IKPowWithIntegerCheck(IKsign(((((32.0)*x480))+(((32.0)*x481)))),-1);
if(!x487.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x486.value)+(((1.5707963267949)*(x487.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x488=IKcos(j0);
IkReal x489=IKsin(j0);
IkReal x490=((1.0)*x488);
IkReal x491=(py*x489);
evalcond[0]=(((px*x489))+(((-1.0)*py*x490)));
evalcond[1]=((-0.128)+(((0.126)*cj2*sj3))+(((-1.0)*px*x490))+(((-1.0)*x491))+(((0.124)*sj2))+(((0.126)*cj3*sj2)));
evalcond[2]=((0.014292)+(((-1.0)*(px*px)))+(((0.048)*pz))+(((-0.256)*x491))+(((0.031248)*cj3))+(((-0.256)*px*x488))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x492=(px*sj2);
IkReal x493=((0.126)*cj3);
IkReal x494=(py*sj2);
IkReal x495=((0.126)*cj2*sj3);
CheckValue<IkReal> x496=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x496.valid){
continue;
}
CheckValue<IkReal> x497 = IKatan2WithCheck(IkReal((((py*x495))+(((0.124)*x494))+((x493*x494))+(((-0.128)*py)))),IkReal(((((0.124)*x492))+((px*x495))+(((-0.128)*px))+((x492*x493)))),IKFAST_ATAN2_MAGTHRESH);
if(!x497.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x496.value)))+(x497.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x498=IKcos(j0);
IkReal x499=IKsin(j0);
IkReal x500=((1.0)*x498);
IkReal x501=(py*x499);
evalcond[0]=((((-1.0)*py*x500))+((px*x499)));
evalcond[1]=((-0.128)+(((0.126)*cj2*sj3))+(((0.124)*sj2))+(((-1.0)*x501))+(((-1.0)*px*x500))+(((0.126)*cj3*sj2)));
evalcond[2]=((0.014292)+(((-1.0)*(px*px)))+(((0.048)*pz))+(((0.031248)*cj3))+(((-0.256)*px*x498))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-0.256)*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x502=(cj2*sj3);
IkReal x503=(py*sj1);
IkReal x504=((0.124)*sj2);
IkReal x505=(cj3*sj2);
IkReal x506=(cj1*px);
IkReal x507=(cj1*py);
IkReal x508=((0.124)*cj2);
IkReal x509=(px*sj1);
IkReal x510=((0.126)*x509);
IkReal x511=((0.126)*sj2*sj3);
IkReal x512=((0.126)*cj1*cj2*cj3);
CheckValue<IkReal> x513 = IKatan2WithCheck(IkReal(((((-0.126)*x503*x505))+(((-0.126)*x502*x503))+(((0.024)*x507))+((x507*x508))+(((-1.0)*x503*x504))+(((0.126)*cj2*cj3*x507))+(((0.128)*x503))+(((-1.0)*x507*x511)))),IkReal(((((-1.0)*x502*x510))+(((0.024)*x506))+((x506*x508))+(((-1.0)*x505*x510))+(((0.126)*cj2*cj3*x506))+(((-1.0)*x506*x511))+(((-1.0)*x504*x509))+(((0.128)*x509)))),IKFAST_ATAN2_MAGTHRESH);
if(!x513.valid){
continue;
}
CheckValue<IkReal> x514=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x514.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x513.value)+(((1.5707963267949)*(x514.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x515=IKcos(j0);
IkReal x516=IKsin(j0);
IkReal x517=((0.126)*cj3);
IkReal x518=((0.124)*cj2);
IkReal x519=(pz*sj1);
IkReal x520=((0.256)*sj1);
IkReal x521=(cj1*pz);
IkReal x522=((0.048)*cj1);
IkReal x523=((0.124)*sj2);
IkReal x524=((1.0)*cj1);
IkReal x525=(px*x515);
IkReal x526=((0.126)*sj2*sj3);
IkReal x527=(py*x516);
IkReal x528=((0.126)*cj2*sj3);
evalcond[0]=(((px*x516))+(((-1.0)*py*x515)));
evalcond[1]=((-0.128)+((sj1*x525))+((sj1*x527))+x523+x521+x528+((sj2*x517)));
evalcond[2]=((0.024)+(((-1.0)*x524*x527))+(((-1.0)*x524*x525))+(((-1.0)*x526))+x519+x518+((cj2*x517)));
evalcond[3]=((((-1.0)*sj1*x528))+(((-1.0)*sj1*x523))+(((0.128)*sj1))+((cj1*cj2*x517))+(((-1.0)*x527))+(((-1.0)*x525))+(((-1.0)*cj1*x526))+(((0.024)*cj1))+((cj1*x518))+(((-1.0)*sj1*sj2*x517)));
evalcond[4]=((0.014292)+((x522*x527))+((x522*x525))+(((-1.0)*(px*px)))+(((0.256)*x521))+(((0.031248)*cj3))+((x520*x525))+((x520*x527))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-0.048)*x519)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x529=(px*sj2);
IkReal x530=((0.126)*cj3);
IkReal x531=(py*sj2);
IkReal x532=((1.0)*cj1*pz);
IkReal x533=((0.126)*cj2*sj3);
CheckValue<IkReal> x534=IKPowWithIntegerCheck(IKsign((((sj1*(py*py)))+((sj1*(px*px))))),-1);
if(!x534.valid){
continue;
}
CheckValue<IkReal> x535 = IKatan2WithCheck(IkReal(((((-0.124)*x531))+(((-1.0)*x530*x531))+(((-1.0)*py*x532))+(((-1.0)*py*x533))+(((0.128)*py)))),IkReal(((((-0.124)*x529))+(((-1.0)*x529*x530))+(((-1.0)*px*x533))+(((-1.0)*px*x532))+(((0.128)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x535.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x534.value)))+(x535.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x536=IKcos(j0);
IkReal x537=IKsin(j0);
IkReal x538=((0.126)*cj3);
IkReal x539=((0.124)*cj2);
IkReal x540=(pz*sj1);
IkReal x541=((0.256)*sj1);
IkReal x542=(cj1*pz);
IkReal x543=((0.048)*cj1);
IkReal x544=((0.124)*sj2);
IkReal x545=((1.0)*cj1);
IkReal x546=(px*x536);
IkReal x547=((0.126)*sj2*sj3);
IkReal x548=(py*x537);
IkReal x549=((0.126)*cj2*sj3);
evalcond[0]=((((-1.0)*py*x536))+((px*x537)));
evalcond[1]=((-0.128)+((sj1*x548))+((sj1*x546))+((sj2*x538))+x544+x542+x549);
evalcond[2]=((0.024)+(((-1.0)*x545*x546))+(((-1.0)*x545*x548))+(((-1.0)*x547))+x540+x539+((cj2*x538)));
evalcond[3]=((((0.128)*sj1))+(((-1.0)*x548))+(((-1.0)*x546))+(((-1.0)*cj1*x547))+(((-1.0)*sj1*x544))+(((-1.0)*sj1*x549))+(((-1.0)*sj1*sj2*x538))+(((0.024)*cj1))+((cj1*x539))+((cj1*cj2*x538)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+(((0.256)*x542))+((x541*x548))+((x541*x546))+(((-0.048)*x540))+(((0.031248)*cj3))+((x543*x548))+((x543*x546))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x550=(pz*sj1);
IkReal x551=((0.124)*cj2);
IkReal x552=((0.126)*sj2*sj3);
IkReal x553=((0.126)*cj2*cj3);
CheckValue<IkReal> x554=IKPowWithIntegerCheck(IKsign((((cj1*(px*px)))+((cj1*(py*py))))),-1);
if(!x554.valid){
continue;
}
CheckValue<IkReal> x555 = IKatan2WithCheck(IkReal((((py*x550))+((py*x551))+((py*x553))+(((0.024)*py))+(((-1.0)*py*x552)))),IkReal((((px*x553))+((px*x550))+((px*x551))+(((-1.0)*px*x552))+(((0.024)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x555.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x554.value)))+(x555.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x556=IKcos(j0);
IkReal x557=IKsin(j0);
IkReal x558=((0.126)*cj3);
IkReal x559=((0.124)*cj2);
IkReal x560=(pz*sj1);
IkReal x561=((0.256)*sj1);
IkReal x562=(cj1*pz);
IkReal x563=((0.048)*cj1);
IkReal x564=((0.124)*sj2);
IkReal x565=((1.0)*cj1);
IkReal x566=(px*x556);
IkReal x567=((0.126)*sj2*sj3);
IkReal x568=(py*x557);
IkReal x569=((0.126)*cj2*sj3);
evalcond[0]=((((-1.0)*py*x556))+((px*x557)));
evalcond[1]=((-0.128)+((sj2*x558))+((sj1*x566))+((sj1*x568))+x569+x564+x562);
evalcond[2]=((0.024)+x559+x560+((cj2*x558))+(((-1.0)*x567))+(((-1.0)*x565*x568))+(((-1.0)*x565*x566)));
evalcond[3]=((((-1.0)*sj1*sj2*x558))+(((0.128)*sj1))+(((0.024)*cj1))+((cj1*x559))+((cj1*cj2*x558))+(((-1.0)*cj1*x567))+(((-1.0)*x568))+(((-1.0)*x566))+(((-1.0)*sj1*x564))+(((-1.0)*sj1*x569)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+((x563*x568))+((x563*x566))+((x561*x566))+((x561*x568))+(((0.031248)*cj3))+(((-0.048)*x560))+(((-1.0)*(pz*pz)))+(((0.256)*x562))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x571 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x571.valid){
continue;
}
IkReal x570=x571.value;
j0array[0]=((-1.0)*x570);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x570)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[2];
IkReal x572=py*py;
IkReal x573=cj0*cj0;
IkReal x574=((((-1.0)*x573*(px*px)))+(((-1.0)*x572))+(((-1.0)*(pz*pz)))+(((-2.0)*cj0*px*py*sj0))+((x572*x573)));
j1eval[0]=x574;
j1eval[1]=IKsign(x574);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x575=((0.126)*sj2);
IkReal x576=(cj3*pz);
IkReal x577=(cj0*px);
IkReal x578=((0.124)*cj2);
IkReal x579=((5.25)*sj3);
IkReal x580=(cj2*pz);
IkReal x581=(py*sj0);
IkReal x582=(cj2*cj3);
IkReal x583=((5.16666666666667)*cj2);
IkReal x584=(pz*sj2);
j1eval[0]=((((-1.0)*x581))+(((-5.25)*x581*x582))+(((-5.25)*sj2*x576))+((sj2*x579*x581))+(((-1.0)*x579*x580))+(((-5.16666666666667)*x584))+(((-1.0)*x577*x583))+(((-1.0)*x577))+((sj2*x577*x579))+(((-5.25)*x577*x582))+(((5.33333333333333)*pz))+(((-1.0)*x581*x583)));
j1eval[1]=IKsign(((((-0.024)*x581))+(((-1.0)*x578*x581))+(((-1.0)*x577*x578))+(((-0.126)*x577*x582))+(((-0.126)*sj3*x580))+(((-0.126)*x581*x582))+(((-0.124)*x584))+(((-1.0)*x575*x576))+((sj3*x575*x581))+(((0.128)*pz))+(((-0.024)*x577))+((sj3*x575*x577))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x585=((5.25)*cj3);
IkReal x586=(cj2*pz);
IkReal x587=(py*sj0);
IkReal x588=((0.126)*cj3);
IkReal x589=((5.25)*sj3);
IkReal x590=(pz*sj2);
IkReal x591=((0.126)*sj3);
IkReal x592=(cj0*px);
IkReal x593=(sj2*x592);
j1eval[0]=(((x585*x593))+(((-5.33333333333333)*x587))+((cj2*x587*x589))+(((5.16666666666667)*sj2*x587))+(((-5.33333333333333)*x592))+(((-5.16666666666667)*x586))+(((-1.0)*pz))+(((-1.0)*x585*x586))+((cj2*x589*x592))+((sj2*x585*x587))+(((5.16666666666667)*x593))+((x589*x590)));
j1eval[1]=IKsign(((((-0.128)*x587))+(((-0.024)*pz))+(((-1.0)*x586*x588))+((cj2*x587*x591))+(((-0.124)*x586))+(((-0.128)*x592))+(((0.124)*x593))+(((0.124)*sj2*x587))+((x590*x591))+((cj2*x591*x592))+((sj2*x587*x588))+((x588*x593))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x594=cj2*cj2;
IkReal x595=cj3*cj3;
IkReal x596=(cj3*sj3);
IkReal x597=(cj2*sj3);
IkReal x598=(cj2*cj3);
IkReal x599=((0.031248)*sj2);
IkReal x600=((0.126)*pz);
IkReal x601=(cj3*sj2);
IkReal x602=(cj0*px);
IkReal x603=((0.124)*sj2);
IkReal x604=(sj2*sj3);
IkReal x605=(cj2*sj2);
IkReal x606=(py*sj0);
IkReal x607=((1.0)*pz);
IkReal x608=((0.031248)*cj3);
IkReal x609=((0.031752)*x595);
CheckValue<IkReal> x610 = IKatan2WithCheck(IkReal(((-0.03176)+(((-0.031752)*x596*x605))+((x594*x608))+((x594*x609))+(((-1.0)*x597*x599))+(((0.031744)*sj2))+(pz*pz)+(((0.032256)*x601))+(((-1.0)*x608))+(((-0.0005)*x594))+(((0.032256)*x597))+(((-0.015876)*x595)))),IkReal(((-0.003072)+((x605*x609))+(((-1.0)*x602*x607))+(((0.031248)*sj3*x594))+((x598*x599))+(((0.016128)*x604))+(((0.003024)*x597))+(((-0.015624)*sj3))+(((-0.015872)*cj2))+(((-0.016128)*x598))+(((-0.0005)*x605))+(((0.003024)*x601))+(((0.002976)*sj2))+(((0.031752)*x594*x596))+(((-1.0)*x606*x607))+(((-0.015876)*x596)))),IKFAST_ATAN2_MAGTHRESH);
if(!x610.valid){
continue;
}
CheckValue<IkReal> x611=IKPowWithIntegerCheck(IKsign(((((0.126)*x601*x602))+(((0.126)*x601*x606))+(((-0.024)*pz))+(((-0.128)*x606))+(((-0.128)*x602))+((x600*x604))+(((-1.0)*x598*x600))+((x603*x606))+(((-0.124)*cj2*pz))+(((0.126)*x597*x606))+(((0.126)*x597*x602))+((x602*x603)))),-1);
if(!x611.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x610.value)+(((1.5707963267949)*(x611.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x612=IKsin(j1);
IkReal x613=IKcos(j1);
IkReal x614=((0.126)*cj2);
IkReal x615=(cj0*px);
IkReal x616=(py*sj0);
IkReal x617=((0.124)*sj2);
IkReal x618=((0.124)*cj2);
IkReal x619=((0.126)*sj2);
IkReal x620=(sj3*x619);
IkReal x621=((1.0)*x613);
IkReal x622=((0.256)*x612);
IkReal x623=((0.048)*x613);
IkReal x624=(cj3*x612);
IkReal x625=(pz*x613);
IkReal x626=(pz*x612);
IkReal x627=(cj3*x613);
evalcond[0]=((-0.128)+((cj3*x619))+((x612*x615))+((x612*x616))+x617+x625+((sj3*x614)));
evalcond[1]=((0.024)+((cj3*x614))+(((-1.0)*x620))+x618+x626+(((-1.0)*x616*x621))+(((-1.0)*x615*x621)));
evalcond[2]=(((x614*x624))+(((-0.128)*x613))+((sj3*x613*x614))+((x619*x627))+((x612*x618))+(((0.024)*x612))+pz+((x613*x617))+(((-1.0)*x612*x620)));
evalcond[3]=((((-1.0)*x612*x617))+((x614*x627))+(((0.128)*x612))+(((-1.0)*x615))+(((-1.0)*x616))+(((0.024)*x613))+((x613*x618))+(((-1.0)*x619*x624))+(((-1.0)*sj3*x612*x614))+(((-1.0)*x613*x620)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+((x616*x622))+((x616*x623))+(((0.256)*x625))+(((0.031248)*cj3))+(((-0.048)*x626))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+((x615*x622))+((x615*x623)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x628=cj2*cj2;
IkReal x629=cj3*cj3;
IkReal x630=((0.126)*cj3);
IkReal x631=(pz*sj2);
IkReal x632=(cj3*sj3);
IkReal x633=(cj0*px);
IkReal x634=(cj2*cj3);
IkReal x635=((0.031248)*sj2);
IkReal x636=(sj2*sj3);
IkReal x637=(py*sj0);
IkReal x638=(cj2*sj2);
IkReal x639=(cj2*sj3);
IkReal x640=(cj2*x633);
IkReal x641=((0.031752)*x629);
IkReal x642=((0.031248)*x628);
CheckValue<IkReal> x643=IKPowWithIntegerCheck(IKsign(((((-0.126)*pz*x639))+(((0.126)*x633*x636))+(((-1.0)*x630*x631))+(((-1.0)*x630*x640))+(((-0.124)*cj2*x637))+(((-0.124)*x640))+(((-0.024)*x637))+(((-0.024)*x633))+(((0.128)*pz))+(((-1.0)*cj2*x630*x637))+(((-0.124)*x631))+(((0.126)*x636*x637)))),-1);
if(!x643.valid){
continue;
}
CheckValue<IkReal> x644 = IKatan2WithCheck(IkReal(((-0.003072)+(((0.003024)*x639))+((x638*x641))+((x634*x635))+((pz*x633))+((pz*x637))+(((-0.015624)*sj3))+(((-0.015872)*cj2))+(((-0.0005)*x638))+(((0.003024)*cj3*sj2))+(((-0.016128)*x634))+(((-0.015876)*x632))+(((0.016128)*x636))+((sj3*x642))+(((0.002976)*sj2))+(((0.031752)*x628*x632)))),IkReal(((-0.016452)+(((-0.006048)*x634))+((x635*x639))+(((-0.005952)*cj2))+(((0.006048)*x636))+(((-1.0)*cj3*x642))+(((0.0005)*x628))+(pz*pz)+(((0.015876)*x629))+(((0.031752)*x632*x638))+(((-1.0)*x628*x641)))),IKFAST_ATAN2_MAGTHRESH);
if(!x644.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x643.value)))+(x644.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x645=IKsin(j1);
IkReal x646=IKcos(j1);
IkReal x647=((0.126)*cj2);
IkReal x648=(cj0*px);
IkReal x649=(py*sj0);
IkReal x650=((0.124)*sj2);
IkReal x651=((0.124)*cj2);
IkReal x652=((0.126)*sj2);
IkReal x653=(sj3*x652);
IkReal x654=((1.0)*x646);
IkReal x655=((0.256)*x645);
IkReal x656=((0.048)*x646);
IkReal x657=(cj3*x645);
IkReal x658=(pz*x646);
IkReal x659=(pz*x645);
IkReal x660=(cj3*x646);
evalcond[0]=((-0.128)+((cj3*x652))+((x645*x649))+((x645*x648))+x650+x658+((sj3*x647)));
evalcond[1]=((0.024)+(((-1.0)*x653))+((cj3*x647))+x651+x659+(((-1.0)*x649*x654))+(((-1.0)*x648*x654)));
evalcond[2]=(((x647*x657))+((x646*x650))+((x645*x651))+((sj3*x646*x647))+pz+(((-0.128)*x646))+((x652*x660))+(((-1.0)*x645*x653))+(((0.024)*x645)));
evalcond[3]=((((-1.0)*x649))+(((-1.0)*x648))+((x646*x651))+(((0.128)*x645))+(((-1.0)*x646*x653))+(((-1.0)*sj3*x645*x647))+(((-1.0)*x645*x650))+(((0.024)*x646))+((x647*x660))+(((-1.0)*x652*x657)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+((x649*x656))+((x649*x655))+(((-0.048)*x659))+((x648*x655))+((x648*x656))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.256)*x658))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x661=py*py;
IkReal x662=cj0*cj0;
IkReal x663=((0.124)*cj2);
IkReal x664=(cj0*px);
IkReal x665=(py*sj0);
IkReal x666=((0.126)*sj3);
IkReal x667=((0.124)*sj2);
IkReal x668=((0.126)*cj3*pz);
IkReal x669=((0.126)*cj2*cj3);
IkReal x670=((0.126)*cj3*sj2);
CheckValue<IkReal> x671=IKPowWithIntegerCheck(IKsign(((((-2.0)*x664*x665))+(((-1.0)*x662*(px*px)))+(((-1.0)*x661))+(((-1.0)*(pz*pz)))+((x661*x662)))),-1);
if(!x671.valid){
continue;
}
CheckValue<IkReal> x672 = IKatan2WithCheck(IkReal((((x665*x670))+((cj2*x668))+((x665*x667))+((x664*x667))+(((-0.128)*x664))+(((-0.128)*x665))+((x664*x670))+((cj2*x664*x666))+((pz*x663))+((cj2*x665*x666))+(((-1.0)*pz*sj2*x666))+(((0.024)*pz)))),IkReal(((((-0.024)*x665))+(((-0.024)*x664))+(((-1.0)*x665*x669))+((sj2*x664*x666))+((cj2*pz*x666))+(((-1.0)*x663*x664))+(((-1.0)*x663*x665))+((sj2*x665*x666))+((pz*x667))+(((-0.128)*pz))+((sj2*x668))+(((-1.0)*x664*x669)))),IKFAST_ATAN2_MAGTHRESH);
if(!x672.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x671.value)))+(x672.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x673=IKsin(j1);
IkReal x674=IKcos(j1);
IkReal x675=((0.126)*cj2);
IkReal x676=(cj0*px);
IkReal x677=(py*sj0);
IkReal x678=((0.124)*sj2);
IkReal x679=((0.124)*cj2);
IkReal x680=((0.126)*sj2);
IkReal x681=(sj3*x680);
IkReal x682=((1.0)*x674);
IkReal x683=((0.256)*x673);
IkReal x684=((0.048)*x674);
IkReal x685=(cj3*x673);
IkReal x686=(pz*x674);
IkReal x687=(pz*x673);
IkReal x688=(cj3*x674);
evalcond[0]=((-0.128)+((x673*x677))+((x673*x676))+((sj3*x675))+x678+x686+((cj3*x680)));
evalcond[1]=((0.024)+((cj3*x675))+(((-1.0)*x681))+x679+x687+(((-1.0)*x677*x682))+(((-1.0)*x676*x682)));
evalcond[2]=(((x673*x679))+(((-0.128)*x674))+((sj3*x674*x675))+(((0.024)*x673))+((x674*x678))+pz+(((-1.0)*x673*x681))+((x680*x688))+((x675*x685)));
evalcond[3]=((((-1.0)*sj3*x673*x675))+(((-1.0)*x680*x685))+(((0.024)*x674))+((x674*x679))+(((0.128)*x673))+(((-1.0)*x676))+(((-1.0)*x677))+(((-1.0)*x674*x681))+((x675*x688))+(((-1.0)*x673*x678)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+(((0.256)*x686))+((x677*x684))+((x677*x683))+((x676*x683))+((x676*x684))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-0.048)*x687))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x690 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x690.valid){
continue;
}
IkReal x689=x690.value;
j0array[0]=((-1.0)*x689);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x689)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j2eval[1];
j2eval[0]=((1.0)+(((2.03225806451613)*cj3))+(((1.03251821019771)*(cj3*cj3)))+(((1.03251821019771)*(sj3*sj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
j1eval[0]=((((py*py)*(sj0*sj0)))+(pz*pz)+(((cj0*cj0)*(px*px)))+(((2.0)*cj0*px*py*sj0)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x691=(py*sj0);
IkReal x692=(cj0*px);
IkReal x693=((((-0.048)*pz))+(((0.256)*x692))+(((0.256)*x691)));
IkReal x694=((((0.048)*x692))+(((0.048)*x691))+(((0.256)*pz)));
CheckValue<IkReal> x697 = IKatan2WithCheck(IkReal(x694),IkReal(x693),IKFAST_ATAN2_MAGTHRESH);
if(!x697.valid){
continue;
}
IkReal x695=((1.0)*(x697.value));
if((((x693*x693)+(x694*x694))) < -0.00001)
continue;
CheckValue<IkReal> x698=IKPowWithIntegerCheck(IKabs(IKsqrt(((x693*x693)+(x694*x694)))),-1);
if(!x698.valid){
continue;
}
if( (((x698.value)*(((0.014292)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x698.value)*(((0.014292)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x696=IKasin(((x698.value)*(((0.014292)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j1array[0]=((((-1.0)*x695))+(((-1.0)*x696)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x696+(((-1.0)*x695)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[2];
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x699=(cj1*cj3);
j2eval[0]=((((1.00012800819252)*cj1))+x699);
j2eval[1]=IKsign(((((15.624)*x699))+(((15.626)*cj1))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x700=(cj3*sj1);
j2eval[0]=((((1.00012800819252)*sj1))+x700);
j2eval[1]=IKsign(((((15.626)*sj1))+(((15.624)*x700))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj1=0;
cj1=1.0;
j1=0;
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x701=((31500.0)*cj3);
IkReal x702=(py*sj0);
IkReal x703=(cj0*px);
IkReal x704=((31500.0)*sj3);
CheckValue<IkReal> x705=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x705.valid){
continue;
}
CheckValue<IkReal> x706 = IKatan2WithCheck(IkReal(((3968.0)+(((-1.0)*pz*x701))+(((-1.0)*x702*x704))+(((-31000.0)*pz))+(((-1.0)*x703*x704))+(((4032.0)*cj3))+(((756.0)*sj3)))),IkReal(((-744.0)+(((-1.0)*pz*x704))+((x701*x703))+((x701*x702))+(((31000.0)*x702))+(((31000.0)*x703))+(((4032.0)*sj3))+(((-756.0)*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x706.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x705.value)))+(x706.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x707=IKsin(j2);
IkReal x708=IKcos(j2);
IkReal x709=(cj3*x707);
IkReal x710=(sj3*x707);
IkReal x711=(sj3*x708);
IkReal x712=(cj3*x708);
evalcond[0]=((-0.128)+(((0.124)*x707))+(((0.126)*x711))+(((0.126)*x709))+pz);
evalcond[1]=((0.024)+(((-0.126)*x710))+(((0.124)*x708))+(((0.126)*x712))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)));
evalcond[2]=((0.048212)+(((-1.0)*(px*px)))+(((-0.031744)*x707))+(((0.006048)*x712))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-0.006048)*x710))+(((0.005952)*x708))+(((-1.0)*(py*py)))+(((-0.032256)*x711))+(((-0.032256)*x709)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x713=((31500.0)*cj3);
IkReal x714=(py*sj0);
IkReal x715=(cj0*px);
IkReal x716=((31500.0)*sj3);
CheckValue<IkReal> x717=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x717.valid){
continue;
}
CheckValue<IkReal> x718 = IKatan2WithCheck(IkReal(((3968.0)+((x715*x716))+((x714*x716))+(((4032.0)*cj3))+(((31000.0)*pz))+((pz*x713))+(((756.0)*sj3)))),IkReal(((-744.0)+(((4032.0)*sj3))+(((-1.0)*x713*x715))+(((-1.0)*x713*x714))+(((-756.0)*cj3))+((pz*x716))+(((-31000.0)*x715))+(((-31000.0)*x714)))),IKFAST_ATAN2_MAGTHRESH);
if(!x718.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x717.value)))+(x718.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x719=IKsin(j2);
IkReal x720=IKcos(j2);
IkReal x721=(sj3*x719);
IkReal x722=(sj3*x720);
IkReal x723=(cj3*x719);
IkReal x724=(cj3*x720);
evalcond[0]=((-0.128)+(((0.124)*x719))+(((0.126)*x723))+(((0.126)*x722))+(((-1.0)*pz)));
evalcond[1]=((0.024)+(((0.126)*x724))+(((-0.126)*x721))+(((0.124)*x720))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.048212)+(((-0.031744)*x719))+(((-1.0)*(px*px)))+(((-0.032256)*x722))+(((-0.032256)*x723))+(((0.006048)*x724))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.005952)*x720))+(((-1.0)*(py*py)))+(((-0.006048)*x721)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x725=((31500.0)*cj3);
IkReal x726=(py*sj0);
IkReal x727=(cj0*px);
IkReal x728=((31500.0)*sj3);
CheckValue<IkReal> x729=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x729.valid){
continue;
}
CheckValue<IkReal> x730 = IKatan2WithCheck(IkReal(((3968.0)+(((-1.0)*x725*x726))+(((-1.0)*x725*x727))+(((4032.0)*cj3))+((pz*x728))+(((-31000.0)*x726))+(((-31000.0)*x727))+(((756.0)*sj3)))),IkReal(((-744.0)+(((-1.0)*x727*x728))+(((-31000.0)*pz))+(((4032.0)*sj3))+(((-1.0)*x726*x728))+(((-756.0)*cj3))+(((-1.0)*pz*x725)))),IKFAST_ATAN2_MAGTHRESH);
if(!x730.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x729.value)))+(x730.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x731=IKcos(j2);
IkReal x732=IKsin(j2);
IkReal x733=(sj3*x732);
IkReal x734=(sj3*x731);
IkReal x735=(cj3*x732);
IkReal x736=(cj3*x731);
evalcond[0]=((0.024)+(((0.124)*x731))+(((0.126)*x736))+(((-0.126)*x733))+pz);
evalcond[1]=((-0.128)+(((0.124)*x732))+(((0.126)*x734))+(((0.126)*x735))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.048212)+(((-0.032256)*x735))+(((-0.032256)*x734))+(((-1.0)*(px*px)))+(((0.006048)*x736))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.005952)*x731))+(((-0.006048)*x733))+(((-1.0)*(py*py)))+(((-0.031744)*x732)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
j2eval[0]=((1.00012800819252)+cj3);
j2eval[1]=IKsign(((7813.0)+(((7812.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x737=((31500.0)*cj3);
IkReal x738=(py*sj0);
IkReal x739=(cj0*px);
IkReal x740=((31500.0)*sj3);
CheckValue<IkReal> x741=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x741.valid){
continue;
}
CheckValue<IkReal> x742 = IKatan2WithCheck(IkReal(((3968.0)+(((-1.0)*pz*x740))+(((4032.0)*cj3))+(((31000.0)*x739))+(((31000.0)*x738))+((x737*x738))+((x737*x739))+(((756.0)*sj3)))),IkReal(((-744.0)+((x738*x740))+((x739*x740))+(((4032.0)*sj3))+(((31000.0)*pz))+((pz*x737))+(((-756.0)*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x742.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x741.value)))+(x742.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x743=IKcos(j2);
IkReal x744=IKsin(j2);
IkReal x745=(cj3*x744);
IkReal x746=(sj3*x744);
IkReal x747=(sj3*x743);
IkReal x748=(cj3*x743);
evalcond[0]=((0.024)+(((-1.0)*pz))+(((0.126)*x748))+(((-0.126)*x746))+(((0.124)*x743)));
evalcond[1]=((-0.128)+(((0.126)*x745))+(((0.126)*x747))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px))+(((0.124)*x744)));
evalcond[2]=((0.048212)+(((-1.0)*(px*px)))+(((-0.031744)*x744))+(((-0.032256)*x747))+(((-0.032256)*x745))+(((0.031248)*cj3))+(((0.005952)*x743))+(((-0.006048)*x746))+(((-1.0)*(pz*pz)))+(((0.006048)*x748))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x749=cj1*cj1;
IkReal x750=((63.0)*cj3);
IkReal x751=(sj1*sj3);
IkReal x752=(cj1*sj1);
IkReal x753=(cj3*sj1);
IkReal x754=((62.0)*pz);
IkReal x755=((63.0)*sj3);
IkReal x756=(py*sj0);
IkReal x757=((63.0)*cj1);
IkReal x758=((62.0)*x756);
IkReal x759=(pz*x749);
IkReal x760=((62.0)*cj0*px);
IkReal x761=(cj0*px*x750);
IkReal x762=(cj0*px*x755);
IkReal x763=(x749*x756);
CheckValue<IkReal> x764 = IKatan2WithCheck(IkReal(((((-1.0)*x750*x756))+((pz*x755))+(((7.936)*sj1))+(((-1.0)*x761))+(((-1.0)*x760))+(((-1.0)*x755*x759))+(((8.064)*x753))+(((1.512)*x751))+(((-1.0)*x752*x754))+(((-1.0)*x751*x756*x757))+((x749*x758))+((x750*x763))+(((-1.0)*pz*x750*x752))+(((-1.0)*x758))+(((-1.0)*cj0*px*x751*x757))+((x749*x761))+((x749*x760)))),IkReal(((((-1.512)*x753))+((x752*x758))+(((-1.488)*sj1))+(((-1.0)*x762))+(((-1.0)*x755*x756))+(((8.064)*x751))+((x752*x761))+((x752*x760))+((x750*x752*x756))+(((-1.0)*pz*x750))+((x749*x754))+((x750*x759))+((x755*x763))+(((-1.0)*x754))+(((-1.0)*pz*x751*x757))+((x749*x762)))),IKFAST_ATAN2_MAGTHRESH);
if(!x764.valid){
continue;
}
CheckValue<IkReal> x765=IKPowWithIntegerCheck(IKsign(((((15.626)*sj1))+(((15.624)*x753)))),-1);
if(!x765.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x764.value)+(((1.5707963267949)*(x765.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x766=IKsin(j2);
IkReal x767=IKcos(j2);
IkReal x768=(cj0*px);
IkReal x769=((0.126)*cj3);
IkReal x770=(py*sj0);
IkReal x771=((0.126)*sj1);
IkReal x772=((1.0)*cj1);
IkReal x773=(cj1*x766);
IkReal x774=(sj3*x766);
IkReal x775=(sj3*x767);
IkReal x776=((0.124)*x767);
IkReal x777=(sj1*x766);
evalcond[0]=((-0.128)+((sj1*x768))+(((0.124)*x766))+((cj1*pz))+(((0.126)*x775))+((sj1*x770))+((x766*x769)));
evalcond[1]=((0.024)+(((-1.0)*x768*x772))+(((-0.126)*x774))+x776+((pz*sj1))+((x767*x769))+(((-1.0)*x770*x772)));
evalcond[2]=((((0.124)*x773))+(((-0.128)*cj1))+(((0.024)*sj1))+((x769*x773))+(((-1.0)*x771*x774))+((sj1*x776))+pz+(((0.126)*cj1*x775))+((sj1*x767*x769)));
evalcond[3]=((0.048212)+(((-1.0)*(px*px)))+(((-0.031744)*x766))+(((-0.032256)*x775))+(((0.006048)*cj3*x767))+(((0.031248)*cj3))+(((-0.006048)*x774))+(((-1.0)*(pz*pz)))+(((0.005952)*x767))+(((-1.0)*(py*py)))+(((-0.032256)*cj3*x766)));
evalcond[4]=((((0.128)*sj1))+((cj1*x776))+(((0.024)*cj1))+(((-0.124)*x777))+(((-1.0)*x771*x775))+(((-1.0)*x769*x777))+(((-1.0)*x768))+(((-1.0)*x770))+(((-0.126)*sj3*x773))+((cj1*x767*x769)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x778=cj1*cj1;
IkReal x779=(cj1*cj3);
IkReal x780=(cj0*px);
IkReal x781=(cj1*sj1);
IkReal x782=((63.0)*sj3);
IkReal x783=((63.0)*sj1);
IkReal x784=((62.0)*pz);
IkReal x785=(cj1*sj3);
IkReal x786=(py*sj0);
IkReal x787=((63.0)*x778);
IkReal x788=((62.0)*x786);
CheckValue<IkReal> x789=IKPowWithIntegerCheck(IKsign(((((15.626)*cj1))+(((15.624)*x779)))),-1);
if(!x789.valid){
continue;
}
CheckValue<IkReal> x790 = IKatan2WithCheck(IkReal((((pz*x781*x782))+(((1.512)*x785))+(((-1.0)*x779*x783*x786))+(((7.936)*cj1))+(((-1.0)*x778*x782*x786))+(((8.064)*x779))+(((-1.0)*x779*x780*x783))+(((-1.0)*x781*x788))+(((-1.0)*x778*x780*x782))+(((-1.0)*cj3*pz*x787))+(((-62.0)*x780*x781))+(((-1.0)*x778*x784)))),IkReal(((((-1.0)*pz*x779*x783))+((cj3*x780*x787))+(((-1.512)*x779))+(((-1.0)*x781*x784))+(((-1.0)*x781*x782*x786))+(((-1.488)*cj1))+((x778*x788))+((cj3*x786*x787))+(((8.064)*x785))+(((-1.0)*x780*x781*x782))+(((62.0)*x778*x780))+(((-1.0)*pz*x778*x782)))),IKFAST_ATAN2_MAGTHRESH);
if(!x790.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x789.value)))+(x790.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x791=IKsin(j2);
IkReal x792=IKcos(j2);
IkReal x793=(cj0*px);
IkReal x794=((0.126)*cj3);
IkReal x795=(py*sj0);
IkReal x796=((0.126)*sj1);
IkReal x797=((1.0)*cj1);
IkReal x798=(cj1*x791);
IkReal x799=(sj3*x791);
IkReal x800=(sj3*x792);
IkReal x801=((0.124)*x792);
IkReal x802=(sj1*x791);
evalcond[0]=((-0.128)+(((0.126)*x800))+((sj1*x795))+((sj1*x793))+((cj1*pz))+(((0.124)*x791))+((x791*x794)));
evalcond[1]=((0.024)+(((-0.126)*x799))+(((-1.0)*x795*x797))+(((-1.0)*x793*x797))+((x792*x794))+((pz*sj1))+x801);
evalcond[2]=((((-1.0)*x796*x799))+(((-0.128)*cj1))+(((0.024)*sj1))+(((0.124)*x798))+pz+((sj1*x792*x794))+((sj1*x801))+((x794*x798))+(((0.126)*cj1*x800)));
evalcond[3]=((0.048212)+(((-0.031744)*x791))+(((-1.0)*(px*px)))+(((0.006048)*cj3*x792))+(((0.031248)*cj3))+(((-0.006048)*x799))+(((-0.032256)*x800))+(((0.005952)*x792))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-0.032256)*cj3*x791)));
evalcond[4]=((((-1.0)*x796*x800))+(((0.128)*sj1))+(((-0.126)*sj3*x798))+(((0.024)*cj1))+(((-0.124)*x802))+((cj1*x801))+(((-1.0)*x795))+(((-1.0)*x793))+(((-1.0)*x794*x802))+((cj1*x792*x794)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x803=(cj0*px);
IkReal x804=((31500.0)*cj3);
IkReal x805=(py*sj0);
IkReal x806=(cj1*pz);
IkReal x807=(pz*sj1);
IkReal x808=((31500.0)*sj3);
IkReal x809=((31000.0)*cj1);
IkReal x810=((31000.0)*sj1);
IkReal x811=(sj1*x808);
IkReal x812=((31500.0)*cj1*x805);
CheckValue<IkReal> x813=IKPowWithIntegerCheck(IKsign(((7813.0)+(((7812.0)*cj3)))),-1);
if(!x813.valid){
continue;
}
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(((3968.0)+(((-1.0)*x803*x810))+(((-1.0)*x804*x806))+(((-1.0)*sj1*x804*x805))+(((-1.0)*cj1*x805*x808))+(((-1.0)*sj1*x803*x804))+(((4032.0)*cj3))+(((-1.0)*cj1*x803*x808))+(((-1.0)*x805*x810))+(((756.0)*sj3))+(((-31000.0)*x806))+((x807*x808)))),IkReal(((-744.0)+(((-1.0)*x803*x811))+(((-1.0)*x804*x807))+(((-1.0)*x806*x808))+((cj1*x803*x804))+((x805*x809))+((x803*x809))+(((4032.0)*sj3))+(((-1.0)*x805*x811))+(((-756.0)*cj3))+((cj1*x804*x805))+(((-31000.0)*x807)))),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x813.value)))+(x814.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x815=IKsin(j2);
IkReal x816=IKcos(j2);
IkReal x817=(cj0*px);
IkReal x818=((0.126)*cj3);
IkReal x819=(py*sj0);
IkReal x820=((0.126)*sj1);
IkReal x821=((1.0)*cj1);
IkReal x822=(cj1*x815);
IkReal x823=(sj3*x815);
IkReal x824=(sj3*x816);
IkReal x825=((0.124)*x816);
IkReal x826=(sj1*x815);
evalcond[0]=((-0.128)+((x815*x818))+((sj1*x819))+((sj1*x817))+((cj1*pz))+(((0.126)*x824))+(((0.124)*x815)));
evalcond[1]=((0.024)+((x816*x818))+(((-1.0)*x819*x821))+(((-1.0)*x817*x821))+(((-0.126)*x823))+((pz*sj1))+x825);
evalcond[2]=(((sj1*x816*x818))+((sj1*x825))+(((-0.128)*cj1))+(((0.126)*cj1*x824))+(((0.024)*sj1))+pz+(((0.124)*x822))+(((-1.0)*x820*x823))+((x818*x822)));
evalcond[3]=((0.048212)+(((-1.0)*(px*px)))+(((0.006048)*cj3*x816))+(((-0.032256)*x824))+(((0.031248)*cj3))+(((-0.006048)*x823))+(((0.005952)*x816))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-0.032256)*cj3*x815))+(((-0.031744)*x815)));
evalcond[4]=((((0.128)*sj1))+(((-0.126)*sj3*x822))+(((-1.0)*x818*x826))+((cj1*x816*x818))+(((0.024)*cj1))+(((-1.0)*x817))+(((-1.0)*x819))+(((-1.0)*x820*x824))+(((-0.124)*x826))+((cj1*x825)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x827=((0.005952)+(((0.006048)*cj3))+(((-0.032256)*sj3)));
IkReal x828=((-0.031744)+(((-0.032256)*cj3))+(((-0.006048)*sj3)));
CheckValue<IkReal> x831 = IKatan2WithCheck(IkReal(x827),IkReal(x828),IKFAST_ATAN2_MAGTHRESH);
if(!x831.valid){
continue;
}
IkReal x829=((1.0)*(x831.value));
if((((x828*x828)+(x827*x827))) < -0.00001)
continue;
CheckValue<IkReal> x832=IKPowWithIntegerCheck(IKabs(IKsqrt(((x828*x828)+(x827*x827)))),-1);
if(!x832.valid){
continue;
}
if( (((x832.value)*(((0.048212)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x832.value)*(((0.048212)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x830=IKasin(((x832.value)*(((0.048212)+(((-1.0)*(px*px)))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j2array[0]=((((-1.0)*x829))+(((-1.0)*x830)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x829))+x830);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[2];
IkReal x833=py*py;
IkReal x834=cj0*cj0;
IkReal x835=(((x833*x834))+(((-1.0)*(pz*pz)))+(((-2.0)*cj0*px*py*sj0))+(((-1.0)*x833))+(((-1.0)*x834*(px*px))));
j1eval[0]=x835;
j1eval[1]=IKsign(x835);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x836=((0.126)*sj2);
IkReal x837=(cj3*pz);
IkReal x838=(cj0*px);
IkReal x839=((0.124)*cj2);
IkReal x840=((5.25)*sj3);
IkReal x841=(cj2*pz);
IkReal x842=(py*sj0);
IkReal x843=(cj2*cj3);
IkReal x844=((5.16666666666667)*cj2);
IkReal x845=(pz*sj2);
j1eval[0]=((((-5.16666666666667)*x845))+(((-5.25)*x842*x843))+(((-1.0)*x840*x841))+((sj2*x838*x840))+(((-1.0)*x842*x844))+(((-5.25)*x838*x843))+(((-1.0)*x838))+(((-1.0)*x842))+(((-1.0)*x838*x844))+((sj2*x840*x842))+(((-5.25)*sj2*x837))+(((5.33333333333333)*pz)));
j1eval[1]=IKsign(((((-0.126)*x838*x843))+(((-0.024)*x838))+(((-0.126)*x842*x843))+(((-1.0)*x836*x837))+((sj3*x836*x842))+((sj3*x836*x838))+(((-0.124)*x845))+(((-1.0)*x838*x839))+(((-1.0)*x839*x842))+(((-0.126)*sj3*x841))+(((0.128)*pz))+(((-0.024)*x842))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x846=((5.25)*cj3);
IkReal x847=(cj2*pz);
IkReal x848=(py*sj0);
IkReal x849=((0.126)*cj3);
IkReal x850=((5.25)*sj3);
IkReal x851=(pz*sj2);
IkReal x852=((0.126)*sj3);
IkReal x853=(cj0*px);
IkReal x854=(sj2*x853);
j1eval[0]=(((x850*x851))+(((5.16666666666667)*x854))+((sj2*x846*x848))+(((-5.16666666666667)*x847))+(((-5.33333333333333)*x848))+(((-1.0)*pz))+(((-1.0)*x846*x847))+((x846*x854))+((cj2*x848*x850))+(((-5.33333333333333)*x853))+((cj2*x850*x853))+(((5.16666666666667)*sj2*x848)));
j1eval[1]=IKsign(((((-1.0)*x847*x849))+(((-0.024)*pz))+(((0.124)*sj2*x848))+(((-0.128)*x848))+((x851*x852))+(((-0.124)*x847))+((cj2*x848*x852))+((x849*x854))+(((0.124)*x854))+((cj2*x852*x853))+(((-0.128)*x853))+((sj2*x848*x849))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x855=cj2*cj2;
IkReal x856=cj3*cj3;
IkReal x857=(cj3*sj3);
IkReal x858=(cj2*sj3);
IkReal x859=(cj2*cj3);
IkReal x860=((0.031248)*sj2);
IkReal x861=((0.126)*pz);
IkReal x862=(cj3*sj2);
IkReal x863=(cj0*px);
IkReal x864=((0.124)*sj2);
IkReal x865=(sj2*sj3);
IkReal x866=(cj2*sj2);
IkReal x867=(py*sj0);
IkReal x868=((1.0)*pz);
IkReal x869=((0.031248)*cj3);
IkReal x870=((0.031752)*x856);
CheckValue<IkReal> x871=IKPowWithIntegerCheck(IKsign(((((-0.024)*pz))+((x863*x864))+(((0.126)*x858*x867))+(((0.126)*x858*x863))+((x861*x865))+(((-0.124)*cj2*pz))+(((-0.128)*x863))+(((-0.128)*x867))+(((-1.0)*x859*x861))+((x864*x867))+(((0.126)*x862*x863))+(((0.126)*x862*x867)))),-1);
if(!x871.valid){
continue;
}
CheckValue<IkReal> x872 = IKatan2WithCheck(IkReal(((-0.03176)+(((-0.0005)*x855))+(((-1.0)*x869))+(((0.032256)*x862))+(((0.032256)*x858))+(((0.031744)*sj2))+(((-0.031752)*x857*x866))+((x855*x870))+((x855*x869))+(pz*pz)+(((-1.0)*x858*x860))+(((-0.015876)*x856)))),IkReal(((-0.003072)+(((0.016128)*x865))+(((-0.016128)*x859))+(((-0.015624)*sj3))+(((-0.015872)*cj2))+(((0.031248)*sj3*x855))+((x866*x870))+(((0.003024)*x858))+((x859*x860))+(((0.003024)*x862))+(((0.002976)*sj2))+(((-0.0005)*x866))+(((-1.0)*x867*x868))+(((0.031752)*x855*x857))+(((-0.015876)*x857))+(((-1.0)*x863*x868)))),IKFAST_ATAN2_MAGTHRESH);
if(!x872.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x871.value)))+(x872.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x873=IKsin(j1);
IkReal x874=IKcos(j1);
IkReal x875=((0.126)*cj2);
IkReal x876=(cj0*px);
IkReal x877=(py*sj0);
IkReal x878=((0.124)*sj2);
IkReal x879=((0.124)*cj2);
IkReal x880=((0.126)*sj2);
IkReal x881=(sj3*x880);
IkReal x882=((1.0)*x874);
IkReal x883=((0.256)*x873);
IkReal x884=((0.048)*x874);
IkReal x885=(cj3*x873);
IkReal x886=(pz*x874);
IkReal x887=(pz*x873);
IkReal x888=(cj3*x874);
evalcond[0]=((-0.128)+((cj3*x880))+((sj3*x875))+((x873*x876))+((x873*x877))+x878+x886);
evalcond[1]=((0.024)+((cj3*x875))+(((-1.0)*x876*x882))+(((-1.0)*x881))+(((-1.0)*x877*x882))+x879+x887);
evalcond[2]=((((-1.0)*x873*x881))+((x880*x888))+((x874*x878))+(((0.024)*x873))+((sj3*x874*x875))+((x873*x879))+pz+((x875*x885))+(((-0.128)*x874)));
evalcond[3]=((((-1.0)*sj3*x873*x875))+((x874*x879))+(((0.024)*x874))+(((-1.0)*x876))+(((-1.0)*x877))+(((-1.0)*x873*x878))+(((0.128)*x873))+((x875*x888))+(((-1.0)*x874*x881))+(((-1.0)*x880*x885)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+(((0.256)*x886))+((x876*x884))+((x876*x883))+((x877*x883))+((x877*x884))+(((0.031248)*cj3))+(((-0.048)*x887))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x889=cj2*cj2;
IkReal x890=cj3*cj3;
IkReal x891=((0.126)*cj3);
IkReal x892=(pz*sj2);
IkReal x893=(cj3*sj3);
IkReal x894=(cj0*px);
IkReal x895=(cj2*cj3);
IkReal x896=((0.031248)*sj2);
IkReal x897=(sj2*sj3);
IkReal x898=(py*sj0);
IkReal x899=(cj2*sj2);
IkReal x900=(cj2*sj3);
IkReal x901=(cj2*x894);
IkReal x902=((0.031752)*x890);
IkReal x903=((0.031248)*x889);
CheckValue<IkReal> x904=IKPowWithIntegerCheck(IKsign(((((-1.0)*x891*x901))+(((0.126)*x894*x897))+(((-1.0)*cj2*x891*x898))+(((-0.124)*x901))+(((0.126)*x897*x898))+(((-0.024)*x898))+(((-0.024)*x894))+(((-0.126)*pz*x900))+(((0.128)*pz))+(((-0.124)*x892))+(((-0.124)*cj2*x898))+(((-1.0)*x891*x892)))),-1);
if(!x904.valid){
continue;
}
CheckValue<IkReal> x905 = IKatan2WithCheck(IkReal(((-0.003072)+((sj3*x903))+(((-0.015624)*sj3))+((pz*x894))+((pz*x898))+(((-0.0005)*x899))+(((-0.015872)*cj2))+((x895*x896))+(((0.003024)*cj3*sj2))+(((-0.016128)*x895))+((x899*x902))+(((0.031752)*x889*x893))+(((-0.015876)*x893))+(((0.002976)*sj2))+(((0.003024)*x900))+(((0.016128)*x897)))),IkReal(((-0.016452)+(((0.0005)*x889))+(((0.015876)*x890))+(((0.031752)*x893*x899))+(((-0.005952)*cj2))+(((-1.0)*x889*x902))+(((0.006048)*x897))+(((-0.006048)*x895))+(pz*pz)+((x896*x900))+(((-1.0)*cj3*x903)))),IKFAST_ATAN2_MAGTHRESH);
if(!x905.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x904.value)))+(x905.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x906=IKsin(j1);
IkReal x907=IKcos(j1);
IkReal x908=((0.126)*cj2);
IkReal x909=(cj0*px);
IkReal x910=(py*sj0);
IkReal x911=((0.124)*sj2);
IkReal x912=((0.124)*cj2);
IkReal x913=((0.126)*sj2);
IkReal x914=(sj3*x913);
IkReal x915=((1.0)*x907);
IkReal x916=((0.256)*x906);
IkReal x917=((0.048)*x907);
IkReal x918=(cj3*x906);
IkReal x919=(pz*x907);
IkReal x920=(pz*x906);
IkReal x921=(cj3*x907);
evalcond[0]=((-0.128)+((sj3*x908))+((x906*x909))+((cj3*x913))+((x906*x910))+x919+x911);
evalcond[1]=((0.024)+((cj3*x908))+(((-1.0)*x914))+(((-1.0)*x910*x915))+x920+x912+(((-1.0)*x909*x915)));
evalcond[2]=((((0.024)*x906))+(((-1.0)*x906*x914))+((x906*x912))+((sj3*x907*x908))+((x907*x911))+pz+((x908*x918))+(((-0.128)*x907))+((x913*x921)));
evalcond[3]=((((0.024)*x907))+(((-1.0)*x913*x918))+(((-1.0)*x906*x911))+((x908*x921))+(((0.128)*x906))+((x907*x912))+(((-1.0)*x910))+(((-1.0)*x909))+(((-1.0)*sj3*x906*x908))+(((-1.0)*x907*x914)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+((x910*x916))+((x910*x917))+((x909*x917))+((x909*x916))+(((0.256)*x919))+(((0.031248)*cj3))+(((-0.048)*x920))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x922=py*py;
IkReal x923=cj0*cj0;
IkReal x924=((0.124)*cj2);
IkReal x925=(cj0*px);
IkReal x926=(py*sj0);
IkReal x927=((0.126)*sj3);
IkReal x928=((0.124)*sj2);
IkReal x929=((0.126)*cj3*pz);
IkReal x930=((0.126)*cj2*cj3);
IkReal x931=((0.126)*cj3*sj2);
CheckValue<IkReal> x932=IKPowWithIntegerCheck(IKsign(((((-1.0)*x923*(px*px)))+(((-2.0)*x925*x926))+(((-1.0)*x922))+(((-1.0)*(pz*pz)))+((x922*x923)))),-1);
if(!x932.valid){
continue;
}
CheckValue<IkReal> x933 = IKatan2WithCheck(IkReal(((((-1.0)*pz*sj2*x927))+(((-0.128)*x925))+(((-0.128)*x926))+((cj2*x929))+((cj2*x926*x927))+((pz*x924))+((cj2*x925*x927))+(((0.024)*pz))+((x925*x931))+((x925*x928))+((x926*x928))+((x926*x931)))),IkReal(((((-1.0)*x925*x930))+(((-0.024)*x925))+(((-0.024)*x926))+((sj2*x926*x927))+(((-1.0)*x924*x925))+(((-1.0)*x924*x926))+(((-1.0)*x926*x930))+((pz*x928))+(((-0.128)*pz))+((sj2*x925*x927))+((sj2*x929))+((cj2*pz*x927)))),IKFAST_ATAN2_MAGTHRESH);
if(!x933.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x932.value)))+(x933.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x934=IKsin(j1);
IkReal x935=IKcos(j1);
IkReal x936=((0.126)*cj2);
IkReal x937=(cj0*px);
IkReal x938=(py*sj0);
IkReal x939=((0.124)*sj2);
IkReal x940=((0.124)*cj2);
IkReal x941=((0.126)*sj2);
IkReal x942=(sj3*x941);
IkReal x943=((1.0)*x935);
IkReal x944=((0.256)*x934);
IkReal x945=((0.048)*x935);
IkReal x946=(cj3*x934);
IkReal x947=(pz*x935);
IkReal x948=(pz*x934);
IkReal x949=(cj3*x935);
evalcond[0]=((-0.128)+((cj3*x941))+((x934*x937))+((x934*x938))+x939+x947+((sj3*x936)));
evalcond[1]=((0.024)+(((-1.0)*x942))+(((-1.0)*x938*x943))+((cj3*x936))+(((-1.0)*x937*x943))+x948+x940);
evalcond[2]=((((-0.128)*x935))+(((0.024)*x934))+((x936*x946))+((x935*x939))+((x941*x949))+pz+((x934*x940))+(((-1.0)*x934*x942))+((sj3*x935*x936)));
evalcond[3]=((((0.128)*x934))+(((-1.0)*sj3*x934*x936))+(((0.024)*x935))+((x936*x949))+(((-1.0)*x941*x946))+(((-1.0)*x934*x939))+(((-1.0)*x937))+(((-1.0)*x938))+((x935*x940))+(((-1.0)*x935*x942)));
evalcond[4]=((0.014292)+(((-1.0)*(px*px)))+((x938*x945))+((x938*x944))+((x937*x944))+((x937*x945))+(((-0.048)*x948))+(((0.031248)*cj3))+(((-1.0)*(pz*pz)))+(((0.256)*x947))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "2062b4aa7fde98f002602493c9ba542a"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
